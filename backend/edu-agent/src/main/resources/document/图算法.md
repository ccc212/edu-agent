## 41. 图算法 (Graph Algorithms)

### 41.1. 图的表示 (Graph Representations)

- **知识点：** 邻接矩阵 (Adjacency Matrix)；邻接列表 (Adjacency List)；有向图 (Directed Graph)；无向图 (Undirected Graph)；加权图 (Weighted Graph)。

1. **题目名称：** 实现图的邻接列表表示并添加边 **题目描述：**

   - 实现一个 `Graph` 类，使用邻接列表来表示图。
   - 提供一个构造器，接收图的节点数量 `V`。
   - 提供一个 `addEdge(int u, int v)` 方法，用于在节点 `u` 和 `v` 之间添加一条边。如果是有向图，只添加 `u` 到 `v` 的边；如果是无向图，同时添加 `u` 到 `v` 和 `v` 到 `u` 的边。
   - 提供一个 `printGraph()` 方法，打印图的邻接列表表示。
   - 在 `main` 方法中，创建一个无向图，添加一些边，并打印其表示。 **输入示例：**

   ```
   V = 5 (节点0到4)
   addEdge(0, 1)
   addEdge(0, 4)
   addEdge(1, 2)
   addEdge(1, 3)
   addEdge(1, 4)
   addEdge(2, 3)
   addEdge(3, 4)
   ```

   **输出示例：**

   ```
   Adjacency List for Graph:
   Vertex 0: -> 1 -> 4
   Vertex 1: -> 0 -> 2 -> 3 -> 4
   Vertex 2: -> 1 -> 3
   Vertex 3: -> 1 -> 2 -> 4
   Vertex 4: -> 0 -> 1 -> 3
   ```

   **知识点描述：**

   - **邻接列表：** 使用 `ArrayList<ArrayList<Integer>>` 或 `ArrayList<LinkedList<Integer>>`，其中外层列表的每个索引代表一个节点，内层列表存储其所有邻居节点。
   - **优点：** 节省空间（尤其对于稀疏图）；方便查找一个节点的所有邻居。
   - **缺点：** 检查两节点间是否存在边相对较慢 (O(deg(V)))。

   **参考代码结构：**

   ```java
   import java.util.ArrayList;
   import java.util.LinkedList;
   
   public class GraphAdjacencyList {
       private int V; // 顶点的数量
       private ArrayList<LinkedList<Integer>> adj; // 邻接列表
   
       // 构造器
       public GraphAdjacencyList(int v) {
           V = v;
           adj = new ArrayList<>(V);
           for (int i = 0; i < V; ++i) {
               adj.add(new LinkedList<>());
           }
       }
   
       // 添加无向边 (u, v)
       public void addEdge(int u, int v) {
           adj.get(u).add(v); // 添加 v 到 u 的邻接列表
           adj.get(v).add(u); // 添加 u 到 v 的邻接列表 (无向图)
       }
   
       // 添加有向边 (u -> v)
       public void addDirectedEdge(int u, int v) {
           adj.get(u).add(v);
       }
   
       // 打印图
       public void printGraph() {
           System.out.println("Adjacency List for Graph:");
           for (int i = 0; i < V; ++i) {
               System.out.print("Vertex " + i + ":");
               for (Integer node : adj.get(i)) {
                   System.out.print(" -> " + node);
               }
               System.out.println();
           }
       }
   
       public static void main(String[] args) {
           GraphAdjacencyList graph = new GraphAdjacencyList(5); // 5个节点 (0-4)
   
           System.out.println("--- Building an Undirected Graph ---");
           graph.addEdge(0, 1);
           graph.addEdge(0, 4);
           graph.addEdge(1, 2);
           graph.addEdge(1, 3);
           graph.addEdge(1, 4);
           graph.addEdge(2, 3);
           graph.addEdge(3, 4);
           graph.printGraph();
   
           System.out.println("\n--- Building a Directed Graph ---");
           GraphAdjacencyList directedGraph = new GraphAdjacencyList(3); // 3个节点 (0-2)
           directedGraph.addDirectedEdge(0, 1);
           directedGraph.addDirectedEdge(1, 2);
           directedGraph.addDirectedEdge(2, 0);
           directedGraph.printGraph();
       }
   }
   ```

### 41.2. 图的遍历 (Graph Traversal)

- **知识点：** 深度优先搜索 (DFS)；广度优先搜索 (BFS)；访问标记 (`visited` 数组)。

1. **题目名称：** 图的广度优先搜索 (BFS) **题目描述：** 给定一个图（使用邻接列表表示）和一个起始节点，实现广度优先搜索算法，并打印遍历的节点顺序。

   - 沿用 `GraphAdjacencyList` 类或重新定义一个。
   - 实现一个静态方法 `bfs(GraphAdjacencyList graph, int startNode)`。
   - 在 `main` 方法中，构建一个示例图并测试 BFS。 **输入示例：** (同上无向图)

   ```
   V = 5 (节点0到4)
   addEdge(0, 1), addEdge(0, 4)
   addEdge(1, 2), addEdge(1, 3), addEdge(1, 4)
   addEdge(2, 3)
   addEdge(3, 4)
   起始节点: 0
   ```

   **输出示例：**

   ```
   BFS Traversal starting from vertex 0:
   0 1 4 2 3
   ```

   **知识点描述：**

   - **工作原理：** 使用队列，从起始节点开始，逐层访问所有邻居。
   - **时间复杂度：** O(V+E) (V 是顶点数，E 是边数)。
   - **空间复杂度：** O(V) (队列空间和 `visited` 数组)。
   - **适用场景：** 查找最短路径（无权图）、查找连通分量、社交网络关系等。

   **参考代码结构：**

   ```java
   import java.util.LinkedList;
   import java.util.Queue;
   import java.util.ArrayList; // 假设 GraphAdjacencyList 是可用的
   
   // GraphAdjacencyList 类同上
   
   public class GraphBFS {
       public static void bfs(GraphAdjacencyList graph, int startNode) {
           int V = graph.getV(); // 获取图的顶点数
           boolean[] visited = new boolean[V]; // 标记节点是否被访问过
           Queue<Integer> queue = new LinkedList<>();
   
           visited[startNode] = true; // 标记起始节点为已访问
           queue.add(startNode);      // 将起始节点入队
   
           System.out.print("BFS Traversal starting from vertex " + startNode + ":");
   
           while (!queue.isEmpty()) {
               int currentNode = queue.poll(); // 出队当前节点
               System.out.print(" " + currentNode);
   
               // 遍历当前节点的所有邻居
               for (int neighbor : graph.getAdj().get(currentNode)) {
                   if (!visited[neighbor]) { // 如果邻居未被访问
                       visited[neighbor] = true; // 标记为已访问
                       queue.add(neighbor);      // 入队
                   }
               }
           }
           System.out.println();
       }
   
       public static void main(String[] args) {
           GraphAdjacencyList graph = new GraphAdjacencyList(5); // 5个节点 (0-4)
           graph.addEdge(0, 1);
           graph.addEdge(0, 4);
           graph.addEdge(1, 2);
           graph.addEdge(1, 3);
           graph.addEdge(1, 4);
           graph.addEdge(2, 3);
           graph.addEdge(3, 4);
   
           bfs(graph, 0); // 从节点0开始BFS
           bfs(graph, 2); // 从节点2开始BFS (在同一个连通分量中)
       }
   }
   ```

2. **题目名称：** 图的深度优先搜索 (DFS) **题目描述：** 给定一个图（使用邻接列表表示）和一个起始节点，实现深度优先搜索算法，并打印遍历的节点顺序。

   - 沿用 `GraphAdjacencyList` 类或重新定义一个。
   - 实现一个静态方法 `dfs(GraphAdjacencyList graph, int startNode)`。
   - 在 `main` 方法中，构建一个示例图并测试 DFS。 **输入示例：** (同上无向图)

   ```
   V = 5 (节点0到4)
   addEdge(0, 1), addEdge(0, 4)
   addEdge(1, 2), addEdge(1, 3), addEdge(1, 4)
   addEdge(2, 3)
   addEdge(3, 4)
   起始节点: 0
   ```

   **输出示例：** (注意DFS路径不唯一，示例为一种可能)

   ```
   DFS Traversal starting from vertex 0:
   0 1 2 3 4
   ```

   **知识点描述：**

   - **工作原理：** 使用递归或栈，从起始节点开始，尽可能深地探索每个分支。
   - **时间复杂度：** O(V+E)。
   - **空间复杂度：** O(V) (递归栈空间或栈空间和 `visited` 数组)。
   - **适用场景：** 查找路径、拓扑排序、查找连通分量、检测环。

   **参考代码结构：**

   ```java
   import java.util.ArrayList;
   import java.util.LinkedList;
   import java.util.Stack; // 迭代实现可以使用栈
   
   // GraphAdjacencyList 类同上
   
   public class GraphDFS {
   
       // 递归实现 DFS
       public static void dfs(GraphAdjacencyList graph, int startNode) {
           int V = graph.getV();
           boolean[] visited = new boolean[V];
           System.out.print("DFS Traversal starting from vertex " + startNode + " (Recursive):");
           dfsRecursive(graph, startNode, visited);
           System.out.println();
       }
   
       private static void dfsRecursive(GraphAdjacencyList graph, int currentNode, boolean[] visited) {
           visited[currentNode] = true; // 标记当前节点为已访问
           System.out.print(" " + currentNode);
   
           // 遍历当前节点的所有邻居
           for (int neighbor : graph.getAdj().get(currentNode)) {
               if (!visited[neighbor]) { // 如果邻居未被访问
                   dfsRecursive(graph, neighbor, visited); // 递归访问邻居
               }
           }
       }
   
       // 迭代实现 DFS (使用栈)
       public static void dfsIterative(GraphAdjacencyList graph, int startNode) {
           int V = graph.getV();
           boolean[] visited = new boolean[V];
           Stack<Integer> stack = new Stack<>();
   
           stack.push(startNode);
           visited[startNode] = true;
   
           System.out.print("DFS Traversal starting from vertex " + startNode + " (Iterative):");
   
           while (!stack.empty()) {
               int currentNode = stack.pop();
               System.out.print(" " + currentNode);
   
               // 遍历邻居，将未访问的邻居压入栈
               // 注意：为了保持与递归相似的输出顺序，通常将邻居逆序压栈
               // 或者遍历时先访问小的邻居，取决于题目对顺序的要求
               for (int neighbor : graph.getAdj().get(currentNode)) { // 假设邻接列表是有序的
                   if (!visited[neighbor]) {
                       visited[neighbor] = true;
                       stack.push(neighbor);
                   }
               }
           }
           System.out.println();
       }
   
   
       public static void main(String[] args) {
           GraphAdjacencyList graph = new GraphAdjacencyList(5); // 5个节点 (0-4)
           graph.addEdge(0, 1);
           graph.addEdge(0, 4);
           graph.addEdge(1, 2);
           graph.addEdge(1, 3);
           graph.addEdge(1, 4);
           graph.addEdge(2, 3);
           graph.addEdge(3, 4);
   
           dfs(graph, 0); // 从节点0开始递归DFS
           dfsIterative(graph, 0); // 从节点0开始迭代DFS
   
           // 考虑非连通图的情况
           GraphAdjacencyList disconnectedGraph = new GraphAdjacencyList(7);
           disconnectedGraph.addEdge(0, 1);
           disconnectedGraph.addEdge(0, 2);
           disconnectedGraph.addEdge(3, 4);
           disconnectedGraph.addEdge(5, 6);
   
           System.out.println("\n--- DFS on Disconnected Graph ---");
           // 对于非连通图，需要从每个未访问的节点开始一次DFS/BFS
           boolean[] visitedFull = new boolean[disconnectedGraph.getV()];
           for (int i = 0; i < disconnectedGraph.getV(); i++) {
               if (!visitedFull[i]) {
                   // 可以将 dfsRecursive 封装在类中，并传递 visitedFull
                   // 这里为了简化，直接在循环里调用
                   System.out.print("DFS Traversal starting from vertex " + i + ":");
                   dfsRecursive(disconnectedGraph, i, visitedFull);
                   System.out.println();
               }
           }
       }
   }
   ```
