## 49. 分治算法 (Divide and Conquer)

### 49.1. 归并排序 (Merge Sort)

- **知识点：** 分治思想；递归；合并操作。

1. **题目名称：** 归并排序实现 **题目描述：** 实现归并排序算法，对给定的整数数组进行升序排列。归并排序是一种稳定的排序算法，基于分治思想。

   - 实现一个静态方法 `mergeSort(int[] arr)`，该方法将对输入数组进行原地排序。
   - 还需要一个辅助方法 `merge(int[] arr, int left, int mid, int right)` 来合并两个已排序的子数组。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   arr = {38, 27, 43, 3, 9, 82, 10}
   ```

   **输出示例：**

   ```
   Original array: [38, 27, 43, 3, 9, 82, 10]
   Sorted array: [3, 9, 10, 27, 38, 43, 82]
   ```

   **知识点描述：**

   - **分：** 将数组递归地分成两半，直到每个子数组只包含一个元素（或为空）。
   - **治：** 对每个子数组（单个元素）进行排序（这部分是平凡的）。
   - **合：** 将排序好的子数组合并成一个更大的排序数组。关键在于 `merge` 操作，它需要两个已排序的数组作为输入，并产生一个合并后的排序数组。
   - **时间复杂度：** 无论最好、最坏、平均情况，均为 O(NlogN) (N 是数组长度)。
   - **空间复杂度：** O(N) (需要一个辅助数组进行合并操作)。
   - **适用场景：** 对稳定性有要求，或者需要处理大规模数据。

   **参考代码结构：**

   ```java
   import java.util.Arrays;
   
   public class MergeSort {
   
       // 主排序方法
       public static void mergeSort(int[] arr) {
           if (arr == null || arr.length <= 1) {
               return; // 数组为空或只有一个元素，无需排序
           }
           sort(arr, 0, arr.length - 1);
       }
   
       // 递归地将数组分成两半并排序
       private static void sort(int[] arr, int left, int right) {
           if (left < right) {
               int mid = left + (right - left) / 2; // 避免 (left + right) 溢出
   
               sort(arr, left, mid);         // 递归排序左半部分
               sort(arr, mid + 1, right);    // 递归排序右半部分
   
               merge(arr, left, mid, right); // 合并两个已排序的子数组
           }
       }
   
       // 合并两个已排序的子数组 arr[left...mid] 和 arr[mid+1...right]
       private static void merge(int[] arr, int left, int mid, int right) {
           int n1 = mid - left + 1;  // 左子数组的长度
           int n2 = right - mid;     // 右子数组的长度
   
           // 创建临时数组
           int[] L = new int[n1];
           int[] R = new int[n2];
   
           // 复制数据到临时数组
           for (int i = 0; i < n1; i++) {
               L[i] = arr[left + i];
           }
           for (int j = 0; j < n2; j++) {
               R[j] = arr[mid + 1 + j];
           }
   
           // 合并临时数组回到 arr[left...right]
           int i = 0, j = 0; // 临时数组的指针
           int k = left;     // 原始数组的起始指针
   
           while (i < n1 && j < n2) {
               if (L[i] <= R[j]) {
                   arr[k] = L[i];
                   i++;
               } else {
                   arr[k] = R[j];
                   j++;
               }
               k++;
           }
   
           // 复制 L 中剩余的元素 (如果有的话)
           while (i < n1) {
               arr[k] = L[i];
               i++;
               k++;
           }
   
           // 复制 R 中剩余的元素 (如果有的话)
           while (j < n2) {
               arr[k] = R[j];
               j++;
               k++;
           }
       }
   
       public static void main(String[] args) {
           int[] arr1 = {38, 27, 43, 3, 9, 82, 10};
           System.out.println("Original array: " + Arrays.toString(arr1));
           mergeSort(arr1);
           System.out.println("Sorted array: " + Arrays.toString(arr1)); // Expected: [3, 9, 10, 27, 38, 43, 82]
   
           int[] arr2 = {5, 4, 3, 2, 1};
           System.out.println("\nOriginal array: " + Arrays.toString(arr2));
           mergeSort(arr2);
           System.out.println("Sorted array: " + Arrays.toString(arr2)); // Expected: [1, 2, 3, 4, 5]
   
           int[] arr3 = {};
           System.out.println("\nOriginal array: " + Arrays.toString(arr3));
           mergeSort(arr3);
           System.out.println("Sorted array: " + Arrays.toString(arr3)); // Expected: []
   
           int[] arr4 = {7};
           System.out.println("\nOriginal array: " + Arrays.toString(arr4));
           mergeSort(arr4);
           System.out.println("Sorted array: " + Arrays.toString(arr4)); // Expected: [7]
       }
   }
   ```

### 49.2. 快速排序 (Quick Sort)

- **知识点：** 分治思想；枢轴元素 (Pivot)；分区操作 (Partition)；原地排序。

1. **题目名称：** 快速排序实现 **题目描述：** 实现快速排序算法，对给定的整数数组进行升序排列。快速排序是一种高效的、不稳定的原地排序算法，基于分治思想。

   - 实现一个静态方法 `quickSort(int[] arr)`，该方法将对输入数组进行原地排序。
   - 还需要一个辅助方法 `partition(int[] arr, int low, int high)` 来执行分区操作，并返回枢轴元素的最终位置。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   arr = {10, 80, 30, 90, 40, 50, 70}
   ```

   **输出示例：**

   ```
   Original array: [10, 80, 30, 90, 40, 50, 70]
   Sorted array: [10, 30, 40, 50, 70, 80, 90]
   ```

   **知识点描述：**

   - **分：** 从数组中选择一个元素作为“枢轴”（pivot）。将数组分为两部分：所有小于枢轴的元素放在枢轴的左边，所有大于枢轴的元素放在枢轴的右边。
   - **治：** 递归地对左右两个子数组进行快速排序。
   - **合：** 子数组排序完成后，整个数组也就有序了（无需显式的合并步骤）。
   - 时间复杂度：
     - 平均情况：O(NlogN)。
     - 最坏情况：O(N2) (如果枢轴选择不当，如总是选择最大或最小元素)。
   - **空间复杂度：** O(logN) (递归栈空间，平均情况) 到 O(N) (最坏情况)。
   - **适用场景：** 通常比归并排序快，但不是稳定的。适合对空间效率有一定要求。

   **参考代码结构：**

   ```java
   import java.util.Arrays;
   import java.util.Random; // 用于随机化枢轴选择
   
   public class QuickSort {
   
       // 主排序方法
       public static void quickSort(int[] arr) {
           if (arr == null || arr.length <= 1) {
               return;
           }
           sort(arr, 0, arr.length - 1);
       }
   
       // 递归地对数组的指定范围进行排序
       private static void sort(int[] arr, int low, int high) {
           if (low < high) {
               // int pivotIndex = partition(arr, low, high); // 固定选择最后一个元素作为枢轴
               int pivotIndex = randomizedPartition(arr, low, high); // 随机选择枢轴，避免最坏情况
   
               sort(arr, low, pivotIndex - 1);  // 递归排序左边子数组
               sort(arr, pivotIndex + 1, high); // 递归排序右边子数组
           }
       }
   
       // 分区操作：选择最后一个元素作为枢轴
       // 将小于等于枢轴的元素放到枢轴左边，大于枢轴的元素放到枢轴右边
       // 返回枢轴最终的位置
       private static int partition(int[] arr, int low, int high) {
           int pivot = arr[high]; // 选择最后一个元素作为枢轴
           int i = (low - 1);     // 指向小于枢轴的元素的最后一个位置
   
           for (int j = low; j < high; j++) {
               // 如果当前元素小于或等于枢轴
               if (arr[j] <= pivot) {
                   i++;
                   // 交换 arr[i] 和 arr[j]
                   int temp = arr[i];
                   arr[i] = arr[j];
                   arr[j] = temp;
               }
           }
   
           // 将枢轴放到正确的位置
           int temp = arr[i + 1];
           arr[i + 1] = arr[high];
           arr[high] = temp;
   
           return i + 1; // 返回枢轴的最终位置
       }
   
       // 随机化分区操作：随机选择一个元素作为枢轴，然后将其与最后一个元素交换
       // 这样可以有效避免最坏情况的发生
       private static int randomizedPartition(int[] arr, int low, int high) {
           Random rand = new Random();
           int randomIndex = rand.nextInt(high - low + 1) + low; // 生成 [low, high] 之间的随机索引
   
           // 将随机选中的元素与最后一个元素交换，然后执行普通分区
           int temp = arr[randomIndex];
           arr[randomIndex] = arr[high];
           arr[high] = temp;
   
           return partition(arr, low, high);
       }
   
       public static void main(String[] args) {
           int[] arr1 = {10, 80, 30, 90, 40, 50, 70};
           System.out.println("Original array: " + Arrays.toString(arr1));
           quickSort(arr1);
           System.out.println("Sorted array: " + Arrays.toString(arr1)); // Expected: [10, 30, 40, 50, 70, 80, 90]
   
           int[] arr2 = {5, 4, 3, 2, 1};
           System.out.println("\nOriginal array: " + Arrays.toString(arr2));
           quickSort(arr2);
           System.out.println("Sorted array: " + Arrays.toString(arr2)); // Expected: [1, 2, 3, 4, 5]
   
           int[] arr3 = {1, 2, 3, 4, 5}; // 已排序数组 (对固定枢轴选择是坏情况)
           System.out.println("\nOriginal array: " + Arrays.toString(arr3));
           quickSort(arr3);
           System.out.println("Sorted array: " + Arrays.toString(arr3)); // Expected: [1, 2, 3, 4, 5]
   
           int[] arr4 = {7};
           System.out.println("\nOriginal array: " + Arrays.toString(arr4));
           quickSort(arr4);
           System.out.println("Sorted array: " + Arrays.toString(arr4)); // Expected: [7]
       }
   }
   ```
