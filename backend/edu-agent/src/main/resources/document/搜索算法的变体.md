## 55. 搜索算法的变体 (Variations of Search Algorithms)

### 55.1. A* 搜索算法 (A* Search Algorithm)

- **知识点：** 启发式搜索；启发函数 (Heuristic Function)；估价函数 f(n)=g(n)+h(n)；优先队列。

1. **题目名称：** 迷宫中的最短路径 (A* 算法) **题目描述：** 给定一个 M×N 的迷宫，用二维整数数组表示，其中 0 代表可以通过的路径，1 代表障碍物。给定起点 `(startX, startY)` 和终点 `(endX, endY)`，请使用 A* 搜索算法找到从起点到终点的最短路径长度。如果无法到达，返回 -1。

   - A* 算法需要一个**启发函数** `h(n)` 来估计从当前节点到目标节点的距离。在本题中，可以使用曼哈顿距离作为启发函数。
   - 实现一个静态方法 `findShortestPathAStar(int[][] maze, int startX, int startY, int endX, int endY)`。
   - 在 `main` 方法中，构建一个示例迷宫并测试你的实现。 **输入示例：**

   ```
   maze = {
       {0, 0, 0, 0},
       {1, 1, 0, 1},
       {0, 0, 0, 0},
       {0, 1, 0, 0}
   }
   startX = 0, startY = 0
   endX = 3, endY = 3
   ```

   **输出示例：**

   ```
   Maze:
   0 0 0 0
   1 1 0 1
   0 0 0 0
   0 1 0 0
   Shortest path length (A*): 7
   ```

   **知识点描述：**

   - **核心思想：** A* 算法是一种启发式搜索算法，结合了 Dijkstra 算法的“实际代价” (`g(n)`) 和最佳优先搜索的“启发式估计” (`h(n)`)。它通过最小化估价函数 f(n)=g(n)+h(n) 来优先扩展节点，从而更有效地找到最短路径。
   - **`g(n)`：** 从起点到当前节点 `n` 的实际代价（路径长度）。
   - **`h(n)`：** 从当前节点 `n` 到目标节点的估计代价（启发式函数）。曼哈顿距离 h((x1,y1),(x2,y2))=∣x1−x2∣+∣y1−y2∣ 是一个常用的、**可接受的 (admissible)** 启发函数（即它从不高估到达目标的实际代价）。
   - **`f(n)`：** 从起点经过节点 `n` 到达目标节点的总估计代价。
   - **数据结构：** 使用**优先队列 (PriorityQueue)** 来存储待探索的节点，优先级基于 `f(n)` 值。还需要一个 `g` 值的数组或 Map 来记录从起点到每个节点的已知最短实际路径，以及一个 `visited` 数组或 `set` 来避免重复处理。
   - **时间复杂度：** 最坏情况接近于 Dijkstra (O(ElogV) 或 O(V2))，但在有良好启发函数的情况下，通常会显著更快。对于网格图，可近似为 O(E) 或 O(VlogV)，取决于具体实现。
   - **空间复杂度：** O(V) (存储 `g` 值、`f` 值和优先队列)。
   - **适用场景：** 图或网格图中的最短路径问题，尤其是当图很大，但目标已知且有可行启发函数时。

   **参考代码结构：**

   ```java
   import java.util.*;
   
   // 迷宫中的节点
   class Cell implements Comparable<Cell> {
       int x, y; // 节点坐标
       int g;    // 从起点到当前节点的实际代价
       int h;    // 从当前节点到终点的启发式估计代价
       int f;    // 总估计代价: g + h
   
       public Cell(int x, int y, int g, int h) {
           this.x = x;
           this.y = y;
           this.g = g;
           this.h = h;
           this.f = g + h;
       }
   
       @Override
       public int compareTo(Cell other) {
           // 优先队列按 f 值排序，f 值小的优先
           return Integer.compare(this.f, other.f);
       }
   
       @Override
       public boolean equals(Object o) {
           if (this == o) return true;
           if (o == null || getClass() != o.getClass()) return false;
           Cell cell = (Cell) o;
           return x == cell.x && y == cell.y;
       }
   
       @Override
       public int hashCode() {
           return Objects.hash(x, y);
       }
   }
   
   public class AStarSearch {
   
       // 定义移动方向：上、下、左、右
       private static final int[] DX = {-1, 1, 0, 0};
       private static final int[] DY = {0, 0, -1, 1};
   
       /**
        * 计算曼哈顿距离作为启发函数 h(n)
        * @param x1, y1 当前节点坐标
        * @param x2, y2 目标节点坐标
        * @return 曼哈顿距离
        */
       private static int calculateManhattanDistance(int x1, int y1, int x2, int y2) {
           return Math.abs(x1 - x2) + Math.abs(y1 - y2);
       }
   
       /**
        * 使用 A* 算法在迷宫中查找最短路径
        * @param maze 迷宫数组 (0: 可通过, 1: 障碍)
        * @param startX, startY 起点坐标
        * @param endX, endY 终点坐标
        * @return 最短路径长度，如果无法到达返回 -1
        */
       public static int findShortestPathAStar(int[][] maze, int startX, int startY, int endX, int endY) {
           int M = maze.length;
           int N = maze[0].length;
   
           // 检查起点和终点是否有效且可通行
           if (startX < 0 || startX >= M || startY < 0 || startY >= N || maze[startX][startY] == 1 ||
               endX < 0 || endX >= M || endY < 0 || endY >= N || maze[endX][endY] == 1) {
               System.out.println("Invalid start or end coordinates, or they are obstacles.");
               return -1;
           }
   
           // 1. 优先队列，存储待探索的 Cell，按 f 值排序
           PriorityQueue<Cell> openSet = new PriorityQueue<>();
   
           // 2. 存储从起点到每个节点的已知最短实际代价 (g 值)
           // 初始化为无穷大
           Map<String, Integer> gScore = new HashMap<>(); // Key: "x,y"
           for (int i = 0; i < M; i++) {
               for (int j = 0; j < N; j++) {
                   gScore.put(i + "," + j, Integer.MAX_VALUE);
               }
           }
   
           // 起点初始化
           gScore.put(startX + "," + startY, 0);
           openSet.add(new Cell(startX, startY, 0, calculateManhattanDistance(startX, startY, endX, endY)));
   
           // 3. 存储已访问过的节点 (避免重复添加到 openSet，也可用于路径重建，但这里只求长度)
           Set<String> closedSet = new HashSet<>(); // 记录已经从 openSet 中取出并处理过的节点
   
           while (!openSet.isEmpty()) {
               Cell current = openSet.poll(); // 取出 f 值最小的节点
   
               // 如果当前节点是终点，返回其 g 值 (即最短路径长度)
               if (current.x == endX && current.y == endY) {
                   return current.g;
               }
   
               // 将当前节点加入 closedSet
               if (closedSet.contains(current.x + "," + current.y)) {
                   continue; // 已经处理过更优的路径
               }
               closedSet.add(current.x + "," + current.y);
   
               // 探索邻居节点
               for (int i = 0; i < 4; i++) {
                   int neighborX = current.x + DX[i];
                   int neighborY = current.y + DY[i];
   
                   // 检查邻居是否在迷宫范围内且不是障碍物
                   if (neighborX >= 0 && neighborX < M && neighborY >= 0 && neighborY < N && maze[neighborX][neighborY] == 0) {
                       // 计算从起点到邻居的潜在 g 值
                       int tentative_gScore = current.g + 1; // 每移动一步代价为 1
   
                       // 如果新的 g 值比已知的 g 值更小，或者邻居尚未被访问
                       if (tentative_gScore < gScore.getOrDefault(neighborX + "," + neighborY, Integer.MAX_VALUE)) {
                           // 更新 g 值
                           gScore.put(neighborX + "," + neighborY, tentative_gScore);
                           // 计算 h 值
                           int h = calculateManhattanDistance(neighborX, neighborY, endX, endY);
                           // 将邻居加入优先队列
                           openSet.add(new Cell(neighborX, neighborY, tentative_gScore, h));
                       }
                   }
               }
           }
   
           return -1; // 无法到达终点
       }
   
       public static void main(String[] args) {
           int[][] maze1 = {
               {0, 0, 0, 0},
               {1, 1, 0, 1},
               {0, 0, 0, 0},
               {0, 1, 0, 0}
           };
           int startX1 = 0, startY1 = 0;
           int endX1 = 3, endY1 = 3;
   
           System.out.println("Maze:");
           for (int[] row : maze1) {
               for (int cell : row) {
                   System.out.print(cell + " ");
               }
               System.out.println();
           }
           int pathLength1 = findShortestPathAStar(maze1, startX1, startY1, endX1, endY1);
           System.out.println("Shortest path length (A*): " + pathLength1); // Expected: 7
   
           System.out.println("\n--- Another Test Case ---");
           int[][] maze2 = {
               {0, 1, 0, 0, 0},
               {0, 1, 0, 1, 0},
               {0, 0, 0, 1, 0},
               {0, 1, 0, 0, 0},
               {0, 0, 0, 1, 0}
           };
           int startX2 = 0, startY2 = 0;
           int endX2 = 4, endY2 = 4;
           System.out.println("Maze:");
           for (int[] row : maze2) {
               for (int cell : row) {
                   System.out.print(cell + " ");
               }
               System.out.println();
           }
           int pathLength2 = findShortestPathAStar(maze2, startX2, startY2, endX2, endY2);
           System.out.println("Shortest path length (A*): " + pathLength2); // Expected: 8
   
           System.out.println("\n--- Test Case: No Path ---");
           int[][] maze3 = {
               {0, 1, 0},
               {1, 1, 1},
               {0, 1, 0}
           };
           int startX3 = 0, startY3 = 0;
           int endX3 = 2, endY3 = 2;
           System.out.println("Maze:");
           for (int[] row : maze3) {
               for (int cell : row) {
                   System.out.print(cell + " ");
               }
               System.out.println();
           }
           int pathLength3 = findShortestPathAStar(maze3, startX3, startY3, endX3, endY3);
           System.out.println("Shortest path length (A*): " + pathLength3); // Expected: -1
       }
   }
   ```
