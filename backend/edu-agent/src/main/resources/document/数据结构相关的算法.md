## 40. 数据结构相关的算法 (Algorithms on Data Structures)

### 40.1. 链表操作 (Linked List Operations)

- **知识点：** 单向链表（Node 结构）；链表的遍历、插入、删除操作；头节点与尾节点。

1. **题目名称：** 反转单向链表 **题目描述：** 给定一个单向链表的头节点，将其反转并返回反转后的链表的头节点。

   - 定义一个 `ListNode` 类，包含 `val` 和 `next` 字段。
   - 实现一个静态方法 `reverseList(ListNode head)`。
   - 在 `main` 方法中，创建一个示例链表，对其进行反转，并打印反转前后的链表内容。 **输入示例：** `1 -> 2 -> 3 -> 4 -> 5 -> null` **输出示例：**

   ```
   Original list: 1 -> 2 -> 3 -> 4 -> 5 -> null
   Reversed list: 5 -> 4 -> 3 -> 2 -> 1 -> null
   ```

   **知识点描述：**

   - **工作原理：** 迭代法通常使用三个指针（`prev`, `curr`, `nextTemp`）来逐个改变节点的 `next` 指向。递归法则将问题分解为反转子链表。
   - **时间复杂度：** O(N)。
   - **空间复杂度：** O(1) (迭代) 或 O(N) (递归栈空间)。

   **参考代码结构：**

   ```java
   class ListNode {
       int val;
       ListNode next;
   
       ListNode(int val) {
           this.val = val;
           this.next = null;
       }
   
       // 辅助方法：从数组创建链表
       public static ListNode fromArray(int[] arr) {
           if (arr == null || arr.length == 0) {
               return null;
           }
           ListNode head = new ListNode(arr[0]);
           ListNode current = head;
           for (int i = 1; i < arr.length; i++) {
               current.next = new ListNode(arr[i]);
               current = current.next;
           }
           return head;
       }
   
       // 辅助方法：打印链表
       public static void printList(ListNode head) {
           ListNode current = head;
           while (current != null) {
               System.out.print(current.val + " -> ");
               current = current.next;
           }
           System.out.println("null");
       }
   }
   
   public class ReverseLinkedList {
       public static ListNode reverseList(ListNode head) {
           // 在这里实现反转链表逻辑
           ListNode prev = null;
           ListNode curr = head;
           while (curr != null) {
               ListNode nextTemp = curr.next; // 保存下一个节点
               curr.next = prev;              // 反转当前节点的指针
               prev = curr;                   // prev 移动到当前节点
               curr = nextTemp;               // curr 移动到下一个节点
           }
           return prev; // prev 最终是新的头节点
       }
   
       public static void main(String[] args) {
           int[] arr = {1, 2, 3, 4, 5};
           ListNode head = ListNode.fromArray(arr);
   
           System.out.print("Original list: ");
           ListNode.printList(head);
   
           ListNode reversedHead = reverseList(head);
           System.out.print("Reversed list: ");
           ListNode.printList(reversedHead);
   
           int[] emptyArr = {};
           ListNode emptyHead = ListNode.fromArray(emptyArr);
           System.out.print("\nOriginal empty list: ");
           ListNode.printList(emptyHead);
           ListNode reversedEmptyHead = reverseList(emptyHead);
           System.out.print("Reversed empty list: ");
           ListNode.printList(reversedEmptyHead);
       }
   }
   ```

2. **题目名称：** 查找链表的中间节点 **题目描述：** 给定一个单向链表的头节点，返回链表的中间节点。如果有两个中间节点（偶数长度链表），返回第二个中间节点。

   - 定义一个 `ListNode` 类（同上）。
   - 实现一个静态方法 `findMiddle(ListNode head)`。
   - 在 `main` 方法中，创建不同长度的链表并测试你的实现。 **输入示例：**
   - `1 -> 2 -> 3 -> 4 -> 5 -> null`
   - `1 -> 2 -> 3 -> 4 -> 5 -> 6 -> null` **输出示例：**

   ```
   Original list: 1 -> 2 -> 3 -> 4 -> 5 -> null
   Middle node value: 3
   
   Original list: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> null
   Middle node value: 4
   ```

   **知识点描述：**

   - **工作原理：** 快慢指针法（Floyd's Tortoise and Hare algorithm）。快指针每次走两步，慢指针每次走一步。当快指针到达链表末尾时，慢指针正好在中间。
   - **时间复杂度：** O(N)。
   - **空间复杂度：** O(1)。

   **参考代码结构：**

   ```java
   // ListNode 类同上
   
   public class FindMiddleOfLinkedList {
       public static ListNode findMiddle(ListNode head) {
           // 在这里实现查找中间节点逻辑
           if (head == null) {
               return null;
           }
           ListNode slow = head;
           ListNode fast = head;
   
           while (fast != null && fast.next != null) {
               slow = slow.next;
               fast = fast.next.next;
           }
           return slow;
       }
   
       public static void main(String[] args) {
           int[] arr1 = {1, 2, 3, 4, 5};
           ListNode head1 = ListNode.fromArray(arr1);
           System.out.print("Original list: ");
           ListNode.printList(head1);
           ListNode middle1 = findMiddle(head1);
           System.out.println("Middle node value: " + (middle1 != null ? middle1.val : "null"));
   
           int[] arr2 = {1, 2, 3, 4, 5, 6};
           ListNode head2 = ListNode.fromArray(arr2);
           System.out.print("\nOriginal list: ");
           ListNode.printList(head2);
           ListNode middle2 = findMiddle(head2);
           System.out.println("Middle node value: " + (middle2 != null ? middle2.val : "null"));
   
           int[] arr3 = {1};
           ListNode head3 = ListNode.fromArray(arr3);
           System.out.print("\nOriginal list: ");
           ListNode.printList(head3);
           ListNode middle3 = findMiddle(head3);
           System.out.println("Middle node value: " + (middle3 != null ? middle3.val : "null"));
   
           ListNode head4 = null;
           System.out.print("\nOriginal list: ");
           ListNode.printList(head4);
           ListNode middle4 = findMiddle(head4);
           System.out.println("Middle node value: " + (middle4 != null ? middle4.val : "null"));
       }
   }
   ```

### 40.2. 树遍历 (Tree Traversal)

- **知识点：** 二叉树节点结构；深度优先遍历 (DFS)：前序、中序、后序；广度优先遍历 (BFS)：层序遍历。

1. **题目名称：** 二叉树的前序、中序、后序遍历 **题目描述：** 给定一个二叉树的根节点，实现其前序遍历、中序遍历和后序遍历，并打印每个节点的值。

   - 定义一个 `TreeNode` 类，包含 `val`, `left`, `right` 字段。
   - 实现三个静态方法：`preorderTraversal(TreeNode root)`, `inorderTraversal(TreeNode root)`, `postorderTraversal(TreeNode root)`。
   - 在 `main` 方法中，构建一个示例二叉树并测试你的遍历方法。 **输入示例：** (以下表示二叉树结构)

   ```
         1
        / \
       2   3
      / \
     4   5
   ```

   **输出示例：**

   ```
   Preorder Traversal: 1 2 4 5 3
   Inorder Traversal: 4 2 5 1 3
   Postorder Traversal: 4 5 2 3 1
   ```

   **知识点描述：**

   - **前序遍历 (Preorder Traversal):** 根 -> 左子树 -> 右子树 (记忆：根在前)
   - **中序遍历 (Inorder Traversal):** 左子树 -> 根 -> 右子树 (记忆：根在中间，对二叉搜索树是升序)
   - **后序遍历 (Postorder Traversal):** 左子树 -> 右子树 -> 根 (记忆：根在后)
   - **递归实现：** 直观，简洁。
   - **时间复杂度：** O(N) (访问每个节点一次)。
   - **空间复杂度：** O(H) (递归栈空间，H 是树的高度，最坏情况 O(N))。

   **参考代码结构：**

   

   ```java
   class TreeNode {
       int val;
       TreeNode left;
       TreeNode right;
   
       TreeNode(int val) {
           this.val = val;
           this.left = null;
           this.right = null;
       }
   
       // 辅助方法：构建示例树 (这里手动构建，也可以实现从数组构建)
       public static TreeNode buildExampleTree() {
           TreeNode root = new TreeNode(1);
           root.left = new TreeNode(2);
           root.right = new TreeNode(3);
           root.left.left = new TreeNode(4);
           root.left.right = new TreeNode(5);
           return root;
       }
   }
   
   public class BinaryTreeTraversals {
   
       // 前序遍历 (根 - 左 - 右)
       public static void preorderTraversal(TreeNode root) {
           if (root == null) {
               return;
           }
           System.out.print(root.val + " "); // 访问根
           preorderTraversal(root.left);     // 遍历左子树
           preorderTraversal(root.right);    // 遍历右子树
       }
   
       // 中序遍历 (左 - 根 - 右)
       public static void inorderTraversal(TreeNode root) {
           if (root == null) {
               return;
           }
           inorderTraversal(root.left);      // 遍历左子树
           System.out.print(root.val + " "); // 访问根
           inorderTraversal(root.right);     // 遍历右子树
       }
   
       // 后序遍历 (左 - 右 - 根)
       public static void postorderTraversal(TreeNode root) {
           if (root == null) {
               return;
           }
           postorderTraversal(root.left);    // 遍历左子树
           postorderTraversal(root.right);   // 遍历右子树
           System.out.print(root.val + " "); // 访问根
       }
   
       public static void main(String[] args) {
           TreeNode root = TreeNode.buildExampleTree();
   
           System.out.print("Preorder Traversal: ");
           preorderTraversal(root);
           System.out.println();
   
           System.out.print("Inorder Traversal: ");
           inorderTraversal(root);
           System.out.println();
   
           System.out.print("Postorder Traversal: ");
           postorderTraversal(root);
           System.out.println();
       }
   }
   ```

2. **题目名称：** 二叉树的层序遍历 **题目描述：** 给定一个二叉树的根节点，实现其层序遍历（广度优先遍历），即按从上到下、从左到右的顺序打印每个节点的值。

   - 定义一个 `TreeNode` 类（同上）。
   - 实现一个静态方法 `levelOrderTraversal(TreeNode root)`。
   - 在 `main` 方法中，构建一个示例二叉树并测试你的遍历方法。 **输入示例：** (同上二叉树结构) **输出示例：**

   ```
   Level Order Traversal: 1 2 3 4 5
   ```

   **知识点描述：**

   - **工作原理：** 使用队列 (Queue) 数据结构。首先将根节点入队，然后循环：出队一个节点，访问它，将其左右子节点（如果存在）入队。
   - **时间复杂度：** O(N) (每个节点入队出队一次)。
   - **空间复杂度：** O(W) (最坏情况 O(N)，W 是树的最大宽度，例如满二叉树的最后一层)。

   **参考代码结构：**

   ```java
   import java.util.LinkedList;
   import java.util.Queue;
   
   // TreeNode 类同上
   
   public class LevelOrderTraversal {
       public static void levelOrderTraversal(TreeNode root) {
           if (root == null) {
               return;
           }
   
           Queue<TreeNode> queue = new LinkedList<>();
           queue.offer(root); // 将根节点入队
   
           while (!queue.isEmpty()) {
               TreeNode node = queue.poll(); // 出队一个节点
               System.out.print(node.val + " "); // 访问该节点
   
               // 将其左右子节点（如果存在）入队
               if (node.left != null) {
                   queue.offer(node.left);
               }
               if (node.right != null) {
                   queue.offer(node.right);
               }
           }
       }
   
       public static void main(String[] args) {
           TreeNode root = TreeNode.buildExampleTree(); // 使用之前定义的辅助方法构建树
   
           System.out.print("Level Order Traversal: ");
           levelOrderTraversal(root);
           System.out.println();
       }
   }
   ```