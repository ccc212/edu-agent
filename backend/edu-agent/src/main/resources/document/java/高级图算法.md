## 47. 高级图算法 (Advanced Graph Algorithms)

### 47.1. 最短路径算法 (Shortest Path Algorithms)

- **知识点：** 单源最短路径 (Single-Source Shortest Path)；所有对最短路径 (All-Pairs Shortest Path)；负权边 (Negative Edges)；环 (Cycles)。

1. **题目名称：** Dijkstra 算法 (Dijkstra's Algorithm) **题目描述：** 给定一个有向图（或无向图）和起始节点，Dijkstra 算法用于查找从起始节点到图中所有其他节点的最短路径。它适用于边权重为非负数的情况。

   - 实现一个静态方法 `dijkstra(int V, List<List<Edge>> adj, int startNode)`，其中 `V` 是顶点数，`adj` 是邻接列表表示的图 (`Edge` 类包含 `to` 和 `weight`)。
   - 返回一个数组，表示从 `startNode` 到每个节点的最小距离。如果无法到达，距离为无穷大。
   - 在 `main` 方法中，构建一个示例加权图并测试你的实现。 **输入示例：**

   ```
   V = 5 (节点0到4)
   图 (邻接列表):
   0: (1, 10), (3, 5)
   1: (2, 1), (3, 2)
   2: (4, 4)
   3: (1, 3), (2, 9), (4, 2)
   4: (0, 7), (2, 6)
   起始节点: 0
   ```

   **输出示例：**

   ```
   Shortest distances from node 0:
   Node 0: 0
   Node 1: 8
   Node 2: 9
   Node 3: 5
   Node 4: 7
   ```

   **知识点描述：**

   - **工作原理：** 使用优先队列 (PriorityQueue) 贪婪地选择当前距离最短的未访问节点进行扩展。它维护一个 `dist` 数组记录从源点到各点的最短距离，并不断更新。
   - **适用条件：** 边权重必须为非负数。
   - **时间复杂度：** 使用优先队列 (基于二叉堆) 时为 O(ElogV) 或 O(E+VlogV) (取决于优先队列实现)。
   - **空间复杂度：** O(V+E)。

   **参考代码结构：**

   ```java
   import java.util.*;
   
   class Edge {
       int to;
       int weight;
   
       public Edge(int to, int weight) {
           this.to = to;
           this.weight = weight;
       }
   }
   
   // 用于优先队列，按距离排序
   class Node implements Comparable<Node> {
       int vertex;
       int distance;
   
       public Node(int vertex, int distance) {
           this.vertex = vertex;
           this.distance = distance;
       }
   
       @Override
       public int compareTo(Node other) {
           return Integer.compare(this.distance, other.distance);
       }
   }
   
   public class DijkstraAlgorithm {
   
       public static int[] dijkstra(int V, List<List<Edge>> adj, int startNode) {
           int[] dist = new int[V];
           Arrays.fill(dist, Integer.MAX_VALUE); // 初始化距离为无穷大
           dist[startNode] = 0; // 起始节点到自身的距离为 0
   
           // 优先队列存储 Node (顶点, 距离)，按距离升序排列
           PriorityQueue<Node> pq = new PriorityQueue<>();
           pq.add(new Node(startNode, 0));
   
           while (!pq.isEmpty()) {
               Node currentNode = pq.poll();
               int u = currentNode.vertex;
               int d = currentNode.distance;
   
               // 如果当前距离 d 大于已记录的最短距离，则跳过 (已找到更短路径)
               if (d > dist[u]) {
                   continue;
               }
   
               // 遍历当前节点的所有邻居
               for (Edge edge : adj.get(u)) {
                   int v = edge.to;
                   int weight = edge.weight;
   
                   // 如果通过当前节点 u 到达 v 的距离更短
                   if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {
                       dist[v] = dist[u] + weight;
                       pq.add(new Node(v, dist[v])); // 将更新后的节点和距离加入优先队列
                   }
               }
           }
           return dist;
       }
   
       public static void main(String[] args) {
           int V = 5;
           // 使用邻接列表表示图
           List<List<Edge>> adj = new ArrayList<>(V);
           for (int i = 0; i < V; i++) {
               adj.add(new ArrayList<>());
           }
   
           // 添加边: (from, to, weight)
           adj.get(0).add(new Edge(1, 10));
           adj.get(0).add(new Edge(3, 5));
           adj.get(1).add(new Edge(2, 1));
           adj.get(1).add(new Edge(3, 2));
           adj.get(1).add(new Edge(4, 4));
           adj.get(2).add(new Edge(4, 4));
           adj.get(3).add(new Edge(1, 3));
           adj.get(3).add(new Edge(2, 9));
           adj.get(3).add(new Edge(4, 2));
           adj.get(4).add(new Edge(0, 7)); // 增加一个环路，确保复杂性
           adj.get(4).add(new Edge(2, 6));
   
   
           int startNode = 0;
           int[] distances = dijkstra(V, adj, startNode);
   
           System.out.println("Shortest distances from node " + startNode + ":");
           for (int i = 0; i < V; i++) {
               System.out.println("Node " + i + ": " + distances[i]);
           }
           // Expected Output:
           // Node 0: 0
           // Node 1: 8 (0->3->1)
           // Node 2: 9 (0->3->1->2)
           // Node 3: 5 (0->3)
           // Node 4: 7 (0->3->4)
   
   
           System.out.println("\n--- Another Test Case ---");
           int V2 = 6; // 0 to 5
           List<List<Edge>> adj2 = new ArrayList<>(V2);
           for (int i = 0; i < V2; i++) {
               adj2.add(new ArrayList<>());
           }
           adj2.get(0).add(new Edge(1, 4));
           adj2.get(0).add(new Edge(2, 2));
           adj2.get(1).add(new Edge(2, 5));
           adj2.get(1).add(new Edge(3, 10));
           adj2.get(2).add(new Edge(3, 8));
           adj2.get(2).add(new Edge(4, 1));
           adj2.get(3).add(new Edge(5, 6));
           adj2.get(4).add(new Edge(3, 3));
           adj2.get(4).add(new Edge(5, 7));
   
           int startNode2 = 0;
           int[] distances2 = dijkstra(V2, adj2, startNode2);
           System.out.println("Shortest distances from node " + startNode2 + ":");
           for (int i = 0; i < V2; i++) {
               System.out.println("Node " + i + ": " + distances2[i]);
           }
           // Expected Output:
           // Node 0: 0
           // Node 1: 4
           // Node 2: 2
           // Node 3: 6 (0->2->4->3)
           // Node 4: 3 (0->2->4)
           // Node 5: 12 (0->2->4->3->5)
       }
   }
   ```

2. **题目名称：** Bellman-Ford 算法 **题目描述：** 给定一个有向图和起始节点，Bellman-Ford 算法用于查找从起始节点到图中所有其他节点的最短路径。与 Dijkstra 不同，它能够处理边权重为负数的情况，并且可以检测图中是否存在负权环。

   - 实现一个静态方法 `bellmanFord(int V, List<EdgeTuple> edges, int startNode)`，其中 `V` 是顶点数，`edges` 是所有边的列表 (`EdgeTuple` 类包含 `from`, `to`, `weight`)。
   - 返回一个数组，表示从 `startNode` 到每个节点的最小距离。如果检测到负权环，则返回 `null`。
   - 在 `main` 方法中，构建一个示例加权图（包含负权边和负权环）并测试你的实现。 **输入示例：**

   ```
   V = 5 (节点0到4)
   边列表:
   (0, 1, -1), (0, 2, 4)
   (1, 2, 3), (1, 3, 2), (1, 4, 2)
   (3, 2, 5), (3, 1, 1)
   (4, 3, -3)
   起始节点: 0
   ```

   **输出示例：**

   ```
   Shortest distances from node 0 (Bellman-Ford):
   Node 0: 0
   Node 1: -1
   Node 2: 2
   Node 3: -2
   Node 4: 1
   ```

   **知识点描述：**

   - **工作原理：** 进行 `V-1` 次迭代，每次迭代放松 (relax) 所有的边。放松操作尝试通过一条边更新目的节点的距离。在第 `k` 次迭代后，所有通过最多 `k` 条边到达的最短路径都会被找到。
   - **负权环检测：** 在 `V-1` 次迭代后，如果进行第 `V` 次迭代时仍有边的距离可以被放松，则说明存在负权环（因为最短路径最多只有 `V-1` 条边）。
   - **时间复杂度：** O(V⋅E)。
   - **空间复杂度：** O(V+E)。
   - **适用场景：** 图中存在负权边，需要检测负权环。

   **参考代码结构：**

   ```java
   import java.util.*;
   
   class EdgeTuple {
       int from;
       int to;
       int weight;
   
       public EdgeTuple(int from, int to, int weight) {
           this.from = from;
           this.to = to;
           this.weight = weight;
       }
   }
   
   public class BellmanFordAlgorithm {
   
       public static int[] bellmanFord(int V, List<EdgeTuple> edges, int startNode) {
           int[] dist = new int[V];
           Arrays.fill(dist, Integer.MAX_VALUE); // 初始化距离为无穷大
           dist[startNode] = 0; // 起始节点到自身的距离为 0
   
           // 进行 V-1 次迭代，每次迭代放松所有边
           for (int i = 1; i < V; i++) {
               for (EdgeTuple edge : edges) {
                   if (dist[edge.from] != Integer.MAX_VALUE && dist[edge.from] + edge.weight < dist[edge.to]) {
                       dist[edge.to] = dist[edge.from] + edge.weight;
                   }
               }
           }
   
           // 第 V 次迭代，检测负权环
           for (EdgeTuple edge : edges) {
               if (dist[edge.from] != Integer.MAX_VALUE && dist[edge.from] + edge.weight < dist[edge.to]) {
                   System.out.println("Graph contains negative cycle!");
                   return null; // 检测到负权环
               }
           }
           return dist;
       }
   
       public static void main(String[] args) {
           int V1 = 5;
           List<EdgeTuple> edges1 = new ArrayList<>();
           edges1.add(new EdgeTuple(0, 1, -1));
           edges1.add(new EdgeTuple(0, 2, 4));
           edges1.add(new EdgeTuple(1, 2, 3));
           edges1.add(new EdgeTuple(1, 3, 2));
           edges1.add(new EdgeTuple(1, 4, 2));
           edges1.add(new EdgeTuple(3, 2, 5));
           edges1.add(new EdgeTuple(3, 1, 1)); // 添加一个边，但不会形成负环
           edges1.add(new EdgeTuple(4, 3, -3));
   
           int startNode1 = 0;
           int[] distances1 = bellmanFord(V1, edges1, startNode1);
   
           if (distances1 != null) {
               System.out.println("Shortest distances from node " + startNode1 + " (Bellman-Ford):");
               for (int i = 0; i < V1; i++) {
                   System.out.println("Node " + i + ": " + distances1[i]);
               }
           }
           // Expected Output:
           // Node 0: 0
           // Node 1: -1
           // Node 2: 2
           // Node 3: -2
           // Node 4: 1
   
   
           System.out.println("\n--- Test with Negative Cycle ---");
           int V2 = 3;
           List<EdgeTuple> edges2 = new ArrayList<>();
           edges2.add(new EdgeTuple(0, 1, 1));
           edges2.add(new EdgeTuple(1, 2, -3));
           edges2.add(new EdgeTuple(2, 0, 1)); // 负权环: 0->1->2->0 (1 + (-3) + 1 = -1)
   
           int startNode2 = 0;
           int[] distances2 = bellmanFord(V2, edges2, startNode2);
           if (distances2 == null) {
               // Expected: Graph contains negative cycle!
           }
       }
   }
   ```

3. **题目名称：** Floyd-Warshall 算法 **题目描述：** Floyd-Warshall 算法是一种多源最短路径算法，用于查找加权图中所有顶点对之间的最短路径。它适用于有向图和无向图，并且可以处理负权边（但不能处理负权环）。

   - 实现一个静态方法 `floydWarshall(int V, int[][] graph)`，其中 `V` 是顶点数，`graph` 是邻接矩阵表示的图（`graph[i][j]` 表示从 `i` 到 `j` 的边权重，如果无边则为无穷大，`i` 到 `i` 为 0）。
   - 返回一个二维数组，`dist[i][j]` 表示从 `i` 到 `j` 的最短距离。如果检测到负权环，算法将给出不正确的结果（通常是通过 `dist[i][i] < 0` 来判断）。
   - 在 `main` 方法中，构建一个示例加权图并测试你的实现。 **输入示例：**

   ```
   V = 4
   graph = {
       {0,   5,  INF, 10},
       {INF, 0,   3, INF},
       {INF, INF, 0,   1},
       {INF, INF, INF, 0}
   } (INF 表示无穷大，即无直接路径)
   ```

   **输出示例：**

   ```
   All-Pairs Shortest Paths (Floyd-Warshall):
   0 5 8 9
   INF 0 3 4
   INF INF 0 1
   INF INF INF 0
   ```

   **知识点描述：**

   - **工作原理：** 动态规划。通过迭代考虑所有中间节点 `k`，来更新所有顶点对 `(i, j)` 之间的最短路径：`dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])`。
   - **时间复杂度：** O(V3)。
   - **空间复杂度：** O(V2)。
   - **适用场景：** 需要计算所有顶点对之间的最短路径，图的顶点数不是很大（因为 V3 复杂度）。

   **参考代码结构：**

   ```java
   import java.util.Arrays;
   
   public class FloydWarshallAlgorithm {
       public static final int INF = Integer.MAX_VALUE / 2; // 使用一个较大的数代表无穷大，避免溢出
   
       public static int[][] floydWarshall(int V, int[][] graph) {
           int[][] dist = new int[V][V];
   
           // 初始化 dist 数组
           for (int i = 0; i < V; i++) {
               for (int j = 0; j < V; j++) {
                   dist[i][j] = graph[i][j];
               }
           }
   
           // 核心的 Floyd-Warshall 逻辑
           // k 作为中间节点
           for (int k = 0; k < V; k++) {
               // i 作为起始节点
               for (int i = 0; i < V; i++) {
                   // j 作为目标节点
                   for (int j = 0; j < V; j++) {
                       // 如果经过 k 的路径比当前路径短
                       if (dist[i][k] != INF && dist[k][j] != INF && dist[i][k] + dist[k][j] < dist[i][j]) {
                           dist[i][j] = dist[i][k] + dist[k][j];
                       }
                   }
               }
           }
   
           // 负权环检测 (可选，但很重要)
           // 如果 dist[i][i] < 0，则存在负权环
           for (int i = 0; i < V; i++) {
               if (dist[i][i] < 0) {
                   System.out.println("Graph contains negative cycle!");
                   // 实际应用中，可以抛出异常或返回特定值
                   // 此处为了展示，继续打印结果，但结果可能不正确
                   // return null;
               }
           }
   
           return dist;
       }
   
       public static void main(String[] args) {
           int V1 = 4;
           int[][] graph1 = {
               {0, 5, INF, 10},
               {INF, 0, 3, INF},
               {INF, INF, 0, 1},
               {INF, INF, INF, 0}
           };
   
           int[][] distances1 = floydWarshall(V1, graph1);
   
           System.out.println("All-Pairs Shortest Paths (Floyd-Warshall):");
           if (distances1 != null) {
               for (int i = 0; i < V1; i++) {
                   for (int j = 0; j < V1; j++) {
                       if (distances1[i][j] == INF) {
                           System.out.print("INF ");
                       } else {
                           System.out.print(distances1[i][j] + "   ");
                       }
                   }
                   System.out.println();
               }
           }
           // Expected Output:
           // 0   5   8   9
           // INF 0   3   4
           // INF INF 0   1
           // INF INF INF 0
   
           System.out.println("\n--- Test with Negative Edge ---");
           int V2 = 3;
           int[][] graph2 = {
               {0, 1, INF},
               {INF, 0, -2},
               {INF, INF, 0}
           };
           int[][] distances2 = floydWarshall(V2, graph2);
           if (distances2 != null) {
               for (int i = 0; i < V2; i++) {
                   for (int j = 0; j < V2; j++) {
                       if (distances2[i][j] == INF) {
                           System.out.print("INF ");
                       } else {
                           System.out.print(distances2[i][j] + "   ");
                       }
                   }
                   System.out.println();
               }
           }
           // Expected Output:
           // 0   1   -1
           // INF 0   -2
           // INF INF 0
   
           System.out.println("\n--- Test with Negative Cycle ---");
           int V3 = 3;
           int[][] graph3 = {
               {0, 1, INF},
               {INF, 0, -3},
               {1, INF, 0} // 2->0 权重为1
           }; // 0->1->2->0 的环: 1 + (-3) + 1 = -1
           int[][] distances3 = floydWarshall(V3, graph3);
           // Expected: Graph contains negative cycle! (如果加入负环检测，dist[0][0]等会变负)
           if (distances3 != null) {
               System.out.println("Distances after negative cycle detection:");
               for (int i = 0; i < V3; i++) {
                   for (int j = 0; j < V3; j++) {
                       if (distances3[i][j] == INF) {
                           System.out.print("INF ");
                       } else {
                           System.out.print(distances3[i][j] + "   ");
                       }
                   }
                   System.out.println();
               }
           }
       }
   }
   ```

### 47.2. 最小生成树 (Minimum Spanning Tree, MST)

- **知识点：** 连通图 (Connected Graph)；无向图 (Undirected Graph)；边权重 (Edge Weights)；循环 (Cycles)。

1. **题目名称：** Kruskal 算法 **题目描述：** Kruskal 算法是一种用于查找连通加权无向图的最小生成树 (MST) 的算法。它通过按权重递增的顺序考虑边，如果添加这条边不会形成环，则将其添加到 MST 中。

   - 实现一个静态方法 `kruskal(int V, List<KruskalEdge> edges)`，其中 `V` 是顶点数，`edges` 是图中所有边的列表 (`KruskalEdge` 类包含 `u`, `v`, `weight`)。
   - 返回 MST 的总权重。你需要实现一个 Union-Find (或 Disjoint Set Union, DSU) 数据结构来检测环。
   - 在 `main` 方法中，构建一个示例加权无向图并测试你的实现。 **输入示例：**

   ```
   V = 4
   edges = {
       (0, 1, 10), (0, 2, 6), (0, 3, 5),
       (1, 3, 15), (2, 3, 4)
   }
   ```

   **输出示例：**

   ```
   Edges in MST (Kruskal's):
   (2, 3, weight: 4)
   (0, 3, weight: 5)
   (0, 1, weight: 10)
   Total weight of MST: 19
   ```

   **知识点描述：**

   - **Union-Find (DSU)：** 用于高效地判断两个节点是否在同一个连通分量中（即是否会形成环），以及将两个连通分量合并。包含 `find(i)` (查找根节点) 和 `union(i, j)` (合并两个集合)。
   - **工作原理：** 贪心算法。将所有边按权重从小到大排序，依次考虑每条边。如果边的两个端点不在同一个连通分量中（即加入这条边不会形成环），就加入 MST 并合并这两个连通分量。
   - **时间复杂度：** O(ElogE) 或 O(ElogV) (排序边的时间占主导)。如果使用路径压缩和按秩合并优化的 Union-Find，Union-Find 操作接近常数时间。
   - **空间复杂度：** O(V+E)。
   - **适用场景：** 查找 MST，尤其适用于边相对较少（稀疏图）的情况。

   **参考代码结构：**

   ```java
   import java.util.*;
   
   // 边类
   class KruskalEdge implements Comparable<KruskalEdge> {
       int u, v, weight;
   
       public KruskalEdge(int u, int v, int weight) {
           this.u = u;
           this.v = v;
           this.weight = weight;
       }
   
       @Override
       public int compareTo(KruskalEdge other) {
           return Integer.compare(this.weight, other.weight);
       }
   
       @Override
       public String toString() {
           return "(" + u + ", " + v + ", weight: " + weight + ")";
       }
   }
   
   // Union-Find (Disjoint Set Union) 数据结构
   class UnionFind {
       int[] parent;
       int[] rank; // 用于按秩合并，优化性能
   
       public UnionFind(int n) {
           parent = new int[n];
           rank = new int[n];
           for (int i = 0; i < n; i++) {
               parent[i] = i; // 初始化：每个元素的父节点是它自己
               rank[i] = 0;   // 初始化：秩为 0
           }
       }
   
       // 查找操作：找到元素的根节点 (带路径压缩)
       public int find(int i) {
           if (parent[i] == i) {
               return i;
           }
           return parent[i] = find(parent[i]); // 路径压缩
       }
   
       // 合并操作：合并两个集合 (按秩合并)
       public boolean union(int i, int j) {
           int rootI = find(i);
           int rootJ = find(j);
   
           if (rootI != rootJ) { // 如果它们不在同一个集合中，则合并
               if (rank[rootI] < rank[rootJ]) {
                   parent[rootI] = rootJ;
               } else if (rank[rootJ] < rank[rootI]) {
                   parent[rootJ] = rootI;
               } else {
                   parent[rootJ] = rootI;
                   rank[rootI]++; // 如果秩相同，任意合并，并将新根的秩加一
               }
               return true; // 成功合并
           }
           return false; // 已经在同一个集合中 (形成环)
       }
   }
   
   public class KruskalAlgorithm {
   
       public static int kruskal(int V, List<KruskalEdge> edges) {
           // 1. 对所有边按权重进行排序
           Collections.sort(edges);
   
           UnionFind uf = new UnionFind(V);
           List<KruskalEdge> mstEdges = new ArrayList<>();
           int totalWeight = 0;
           int edgesCount = 0; // 记录已加入 MST 的边数
   
           // 2. 遍历排序后的边
           for (KruskalEdge edge : edges) {
               // 如果加入这条边不会形成环
               if (uf.union(edge.u, edge.v)) {
                   mstEdges.add(edge);
                   totalWeight += edge.weight;
                   edgesCount++;
   
                   // 如果 MST 中的边数达到 V-1 (对于连通图)，则 MST 已构建完成
                   if (edgesCount == V - 1) {
                       break;
                   }
               }
           }
   
           // 打印 MST 中的边
           System.out.println("Edges in MST (Kruskal's):");
           for (KruskalEdge edge : mstEdges) {
               System.out.println(edge);
           }
   
           // 检查是否所有节点都连通（即是否形成了完整的MST）
           if (edgesCount != V - 1 && V > 1) {
               System.out.println("Warning: Graph is not connected, a spanning forest is formed.");
           }
   
           return totalWeight;
       }
   
       public static void main(String[] args) {
           int V1 = 4; // 顶点数
           List<KruskalEdge> edges1 = new ArrayList<>();
           edges1.add(new KruskalEdge(0, 1, 10));
           edges1.add(new KruskalEdge(0, 2, 6));
           edges1.add(new KruskalEdge(0, 3, 5));
           edges1.add(new KruskalEdge(1, 3, 15));
           edges1.add(new KruskalEdge(2, 3, 4));
   
           int totalWeight1 = kruskal(V1, edges1);
           System.out.println("Total weight of MST: " + totalWeight1); // Expected: 19
   
           System.out.println("\n--- Another Test Case ---");
           int V2 = 7; // 7个顶点
           List<KruskalEdge> edges2 = new ArrayList<>();
           edges2.add(new KruskalEdge(0, 1, 7));
           edges2.add(new KruskalEdge(0, 3, 5));
           edges2.add(new KruskalEdge(1, 2, 8));
           edges2.add(new KruskalEdge(1, 3, 9));
           edges2.add(new KruskalEdge(1, 4, 7));
           edges2.add(new KruskalEdge(2, 4, 5));
           edges2.add(new KruskalEdge(3, 4, 15));
           edges2.add(new KruskalEdge(3, 5, 6));
           edges2.add(new KruskalEdge(4, 5, 8));
           edges2.add(new KruskalEdge(4, 6, 9));
           edges2.add(new KruskalEdge(5, 6, 11));
   
           int totalWeight2 = kruskal(V2, edges2);
           System.out.println("Total weight of MST: " + totalWeight2); // Expected: 39
       }
   }
   ```
