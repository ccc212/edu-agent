## 24. 并发进阶 (Advanced Concurrency)

### 24.1. `CompletableFuture` (`CompletableFuture`)

- **知识点：** 异步编程；`Future` 的局限性；`CompletableFuture` 的优势（链式调用，组合多个异步任务）；`supplyAsync()` (有返回值)；`runAsync()` (无返回值)；`thenApply()`, `thenAccept()`, `thenRun()` (转换与消费结果)；`thenCompose()`, `thenCombine()` (组合异步任务)；异常处理 (`exceptionally`, `handle`)。

1. **题目名称：** 链式异步操作 **题目描述：**

   - 模拟一个异步任务：`fetchUserId(String username)`，模拟从用户服务获取用户 ID，返回 `CompletableFuture<Integer>`。
   - 模拟另一个异步任务：`fetchUserDetails(int userId)`，模拟从详情服务获取用户详情（例如 `String` 类型的用户名称），返回 `CompletableFuture<String>`。
   - 在 `main` 方法中，使用 `CompletableFuture` 链式调用这两个任务：首先获取用户 ID，然后基于该 ID 获取用户详情，并最终打印用户详情。
   - 处理可能发生的异常（例如用户不存在）。 **参考代码结构：**

   ```java
   import java.util.concurrent.CompletableFuture;
   import java.util.concurrent.Executors;
   import java.util.concurrent.TimeUnit;
   
   public class CompletableFutureChain {
   
       // 模拟异步获取用户ID
       public static CompletableFuture<Integer> fetchUserId(String username) {
           return CompletableFuture.supplyAsync(() -> {
               try {
                   TimeUnit.MILLISECONDS.sleep(500); // 模拟网络延迟
               } catch (InterruptedException e) {
                   Thread.currentThread().interrupt();
               }
               if ("Alice".equals(username)) {
                   return 101;
               } else if ("Bob".equals(username)) {
                   return 102;
               } else {
                   // throw new RuntimeException("User not found: " + username); // 模拟异常
                   return null; // 或者返回Optional
               }
           }, Executors.newCachedThreadPool()); // 使用线程池
       }
   
       // 模拟异步获取用户详情
       public static CompletableFuture<String> fetchUserDetails(Integer userId) {
           return CompletableFuture.supplyAsync(() -> {
               try {
                   TimeUnit.MILLISECONDS.sleep(300); // 模拟网络延迟
               } catch (InterruptedException e) {
                   Thread.currentThread().interrupt();
               }
               if (userId != null) {
                   return "Details for User " + userId;
               } else {
                   // throw new RuntimeException("Invalid userId for details"); // 模拟异常
                   return "Details Not Available";
               }
           }, Executors.newCachedThreadPool());
       }
   
       public static void main(String[] args) {
           // 链式调用示例1：成功路径
           System.out.println("--- Scenario 1: Alice ---");
           fetchUserId("Alice")
               .thenCompose(CompletableFutureChain::fetchUserDetails) // 基于前一个结果进行下一个异步操作
               .thenAccept(details -> System.out.println("User details: " + details)) // 消费最终结果
               .exceptionally(ex -> { // 异常处理
                   System.err.println("Error in chain for Alice: " + ex.getMessage());
                   return null;
               });
   
           // 链式调用示例2：用户不存在的异常路径
           System.out.println("\n--- Scenario 2: UnknownUser ---");
           fetchUserId("UnknownUser")
               .thenCompose(CompletableFutureChain::fetchUserDetails)
               .thenAccept(details -> System.out.println("User details: " + details))
               .exceptionally(ex -> {
                   System.err.println("Error in chain for UnknownUser: " + ex.getMessage());
                   return null; // 返回null以避免继续传播异常
               });
   
           // 确保异步任务有时间执行完成
           try {
               TimeUnit.SECONDS.sleep(2);
           } catch (InterruptedException e) {
               Thread.currentThread().interrupt();
           }
       }
   }
   ```

2. **题目名称：** 组合多个异步任务 (Parallel Tasks) **题目描述：**

   - 模拟两个独立的异步任务：`fetchProductPrice(String productId)` 和 `fetchProductReviews(String productId)`，分别返回 `CompletableFuture<Double>` 和 `CompletableFuture<Integer>` (评论数量)。
   - 在 `main` 方法中，同时启动这两个异步任务，并使用 `CompletableFuture.thenCombine()` 在两个任务都完成后，将它们的结果组合起来，打印产品的价格和评论数量。 **参考代码结构：**

   ```java
   import java.util.concurrent.CompletableFuture;
   import java.util.concurrent.Executors;
   import java.util.concurrent.TimeUnit;
   
   public class CompletableFutureCombine {
   
       // 模拟异步获取产品价格
       public static CompletableFuture<Double> fetchProductPrice(String productId) {
           return CompletableFuture.supplyAsync(() -> {
               try {
                   TimeUnit.MILLISECONDS.sleep(700); // 模拟网络延迟
               } catch (InterruptedException e) {
                   Thread.currentThread().interrupt();
               }
               System.out.println("Fetched price for " + productId);
               if ("P001".equals(productId)) return 99.99;
               return 0.0;
           });
       }
   
       // 模拟异步获取产品评论数量
       public static CompletableFuture<Integer> fetchProductReviews(String productId) {
           return CompletableFuture.supplyAsync(() -> {
               try {
                   TimeUnit.MILLISECONDS.sleep(400); // 模拟网络延迟
               } catch (InterruptedException e) {
                   Thread.currentThread().interrupt();
               }
               System.out.println("Fetched reviews for " + productId);
               if ("P001".equals(productId)) return 150;
               return 0;
           });
       }
   
       public static void main(String[] args) {
           String productId = "P001";
   
           // 同时启动两个异步任务
           CompletableFuture<Double> priceFuture = fetchProductPrice(productId);
           CompletableFuture<Integer> reviewsFuture = fetchProductReviews(productId);
   
           // 组合两个任务的结果
           CompletableFuture<String> combinedFuture = priceFuture.thenCombine(
               reviewsFuture,
               (price, reviews) -> "Product " + productId + " Price: $" + price + ", Reviews: " + reviews
           );
   
           // 获取最终结果并打印
           combinedFuture.thenAccept(System.out::println)
                         .exceptionally(ex -> {
                             System.err.println("Error combining futures: " + ex.getMessage());
                             return null;
                         });
   
           // 确保异步任务有时间执行完成
           try {
               TimeUnit.SECONDS.sleep(1);
           } catch (InterruptedException e) {
               Thread.currentThread().interrupt();
           }
       }
   }
   ```

### 24.2. `Fork/Join Framework` (`Fork/Join Framework`)

- **知识点：** 分而治之 (Divide and Conquer) 思想；`ForkJoinPool`；`RecursiveTask` (有返回值)；`RecursiveAction` (无返回值)；工作窃取 (Work-Stealing) 算法；适用于计算密集型任务。

1. 题目名称：

    使用 Fork/Join 计算大数组的和

   题目描述：

   - 创建一个包含大量随机整数的数组（例如 100 万个）。

   - 定义一个继承自 `RecursiveTask<Long>` 的任务类 `SumArrayTask`。

   - 在 

     ```
     compute()
     ```

      方法中：

     - 如果数组大小小于某个阈值（例如 10000），则直接计算子数组的和。
     - 否则，将数组分成两半，创建两个新的 `SumArrayTask` 实例，并行执行（`fork()`），然后等待子任务完成并合并结果（`join()`）。

   - 在 `main` 方法中，使用 `ForkJoinPool` 执行这个任务，并打印计算结果和执行时间，与单线程计算进行比较。 **参考代码结构：**

   ```java
   import java.util.Random;
   import java.util.concurrent.ForkJoinPool;
   import java.util.concurrent.RecursiveTask;
   
   public class ForkJoinSumArray {
       private static final int THRESHOLD = 10000; // 阈值，小于此值直接计算
       private int[] array;
       private int start;
       private int end;
   
       public ForkJoinSumArray(int[] array, int start, int end) {
           this.array = array;
           this.start = start;
           this.end = end;
       }
   
       @Override
       protected Long compute() {
           // 在这里编写你的Fork/Join逻辑
           long sum = 0;
           int length = end - start;
   
           if (length <= THRESHOLD) {
               // 直接计算
               for (int i = start; i < end; i++) {
                   sum += array[i];
               }
               return sum;
           } else {
               // 分割任务
               int mid = start + length / 2;
               ForkJoinSumArray leftTask = new ForkJoinSumArray(array, start, mid);
               ForkJoinSumArray rightTask = new ForkJoinSumArray(array, mid, end);
   
               // 异步执行左任务
               leftTask.fork();
   
               // 执行右任务 (可以同步执行或再次fork)
               long rightResult = rightTask.compute();
   
               // 等待左任务完成并合并结果
               long leftResult = leftTask.join();
   
               return leftResult + rightResult;
           }
       }
   
       public static void main(String[] args) {
           int arraySize = 1_000_000;
           int[] numbers = new int[arraySize];
           Random random = new Random();
           for (int i = 0; i < arraySize; i++) {
               numbers[i] = random.nextInt(100); // 0-99
           }
   
           // 使用 Fork/Join 框架计算
           long startTimeFJ = System.nanoTime();
           ForkJoinPool forkJoinPool = new ForkJoinPool();
           long resultFJ = forkJoinPool.invoke(new ForkJoinSumArray(numbers, 0, arraySize));
           long endTimeFJ = System.nanoTime();
           System.out.println("Fork/Join Sum: " + resultFJ);
           System.out.println("Fork/Join Time: " + (endTimeFJ - startTimeFJ) / 1_000_000.0 + " ms");
   
           // 单线程计算作为对比
           long startTimeSingle = System.nanoTime();
           long singleSum = 0;
           for (int number : numbers) {
               singleSum += number;
           }
           long endTimeSingle = System.nanoTime();
           System.out.println("Single Thread Sum: " + singleSum);
           System.out.println("Single Thread Time: " + (endTimeSingle - startTimeSingle) / 1_000_000.0 + " ms");
       }
   }
   ```