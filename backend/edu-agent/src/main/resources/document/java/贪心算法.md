## 52. 贪心算法 (Greedy Algorithms)

### 52.1. 活动选择问题 (Activity Selection Problem)

- **知识点：** 贪心选择性质；最优子结构；排序。

1. **题目名称：** 活动选择问题 **题目描述：** 假设有 `N` 个活动，每个活动都有一个开始时间 `start[i]` 和结束时间 `end[i]`。你希望参加尽可能多的活动，但条件是不能同时参加两个活动（即如果一个活动结束时间是 `T`，另一个活动开始时间是 `T` 或 `T+1`，则可以参加）。找到能够参加的最大活动数量。

   - 实现一个静态方法 `maxActivities(int[] start, int[] end)`。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   start = {1, 3, 0, 5, 8, 5}
   end =   {2, 4, 6, 7, 9, 9}
   ```

   **输出示例：**

   ```
   Activities:
   (1, 2)
   (3, 4)
   (5, 7)
   (8, 9)
   Maximum number of activities: 4
   ```

   **知识点描述：**

   - **贪心策略：** 总是选择当前可以开始的活动中，结束时间最早的那个。
   - **证明：** 假设最优解中不包含结束时间最早的活动 `A`，而是包含另一个活动 `B`。如果 `B` 的结束时间晚于 `A`，那么将 `B` 替换为 `A` 后，剩余的时间会更多，可以安排更多或同样多的活动，因此替换后的方案仍然是最优的。如果 `B` 的结束时间早于或等于 `A`，那么 `A` 仍然是更优或同样优的选择。
   - 步骤：
     1. 将所有活动按结束时间升序排序。
     2. 选择第一个活动。
     3. 从第二个活动开始遍历，如果当前活动的开始时间大于等于上一个已选择活动的结束时间，则选择该活动。
   - **时间复杂度：** O(NlogN) (排序时间占主导)。
   - **空间复杂度：** O(N) (存储活动对象或配对)。

   **参考代码结构：**

   ```java
   import java.util.ArrayList;
   import java.util.Collections;
   import java.util.Comparator;
   import java.util.List;
   
   // 表示一个活动
   class Activity {
       int start;
       int end;
   
       public Activity(int start, int end) {
           this.start = start;
           this.end = end;
       }
   
       @Override
       public String toString() {
           return "(" + start + ", " + end + ")";
       }
   }
   
   public class ActivitySelection {
   
       public static int maxActivities(int[] start, int[] end) {
           int n = start.length;
           if (n == 0) {
               return 0;
           }
   
           List<Activity> activities = new ArrayList<>();
           for (int i = 0; i < n; i++) {
               activities.add(new Activity(start[i], end[i]));
           }
   
           // 1. 按照活动的结束时间进行排序
           Collections.sort(activities, Comparator.comparingInt(a -> a.end));
   
           System.out.println("Sorted activities by end time:");
           for (Activity act : activities) {
               System.out.println(act);
           }
   
           int count = 1; // 至少可以参加第一个活动
           List<Activity> selectedActivities = new ArrayList<>();
           selectedActivities.add(activities.get(0)); // 选择第一个活动（结束时间最早的）
           int lastEndTime = activities.get(0).end;
   
           // 2. 遍历其余活动
           for (int i = 1; i < n; i++) {
               // 如果当前活动的开始时间 >= 上一个已选择活动的结束时间
               if (activities.get(i).start >= lastEndTime) {
                   count++;
                   selectedActivities.add(activities.get(i));
                   lastEndTime = activities.get(i).end; // 更新结束时间
               }
           }
   
           System.out.println("\nActivities selected:");
           for (Activity act : selectedActivities) {
               System.out.println(act);
           }
   
           return count;
       }
   
       public static void main(String[] args) {
           int[] start1 = {1, 3, 0, 5, 8, 5};
           int[] end1 = {2, 4, 6, 7, 9, 9};
           System.out.println("Maximum number of activities: " + maxActivities(start1, end1)); // Expected: 4
   
           System.out.println("\n--- Another Test Case ---");
           int[] start2 = {10, 12, 20};
           int[] end2 = {20, 25, 30};
           System.out.println("Maximum number of activities: " + maxActivities(start2, end2)); // Expected: 2 ( (10,20), (20,30) )
       }
   }
   ```

### 52.2. 钱币找零问题 (Coin Change - Greedy Approach)

- **知识点：** 贪心算法在特定情况下的适用性；不能解决所有找零问题。

1. **题目名称：** 钱币找零问题 (贪心算法) **题目描述：** 假设有若干面值的硬币 `coins` (例如，人民币面值 1, 5, 10, 20, 50, 100)，你需要凑出指定的总金额 `amount`。请使用贪心算法计算所需的最少硬币数量。**注意：** 贪心算法不适用于所有硬币面值组合，但本题目假定给定的 `coins` 数组使得贪心算法能够得到最优解（例如，包含 1 的标准货币系统）。

   - 实现一个静态方法 `greedyCoinChange(int[] coins, int amount)`。
   - 返回一个整数数组，表示每种面值使用的数量，或者返回总硬币数。如果无法凑成，返回 -1。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   coins = {100, 50, 20, 10, 5, 1}, amount = 137
   ```

   **输出示例：**

   ```
   Amount: 137, Coins: [100, 50, 20, 10, 5, 1]
   Coins used:
   100 x 1
   20 x 1
   10 x 1
   5 x 1
   1 x 2
   Total coins: 5
   ```

   **知识点描述：**

   - **贪心策略：** 总是优先使用面值最大的硬币，直到不能再用为止，然后使用次大面值的硬币，以此类推。
   - **适用条件：** 对于“标准货币系统”（如大多数国家的主流货币面值，包含 1），贪心算法可以得到最优解。但对于某些自定义面值组合（如 {1, 3, 4} 凑 6，贪心会用 4+1+1=3个，最优解是 3+3=2个），贪心算法可能不是最优解。
   - 步骤：
     1. 将硬币面值按降序排序。
     2. 从最大面值硬币开始，尽可能多地使用该硬币，同时减少 `amount`。
     3. 继续使用下一个面值的硬币，直到 `amount` 为 0。
   - **时间复杂度：** O(MlogM) (排序硬币面值) + O(M) (遍历硬币面值)，其中 M 是硬币面值的种类数。
   - **空间复杂度：** O(1) (不计输入输出存储)。

   **参考代码结构：**

   ```java
   import java.util.Arrays;
   import java.util.Collections;
   import java.util.HashMap;
   import java.util.Map;
   
   public class GreedyCoinChange {
   
       public static int greedyCoinChange(int[] coins, int amount) {
           if (amount < 0) {
               return -1; // 金额不能为负
           }
           if (amount == 0) {
               return 0; // 凑 0 元需要 0 个硬币
           }
   
           // 1. 将硬币面值从大到小排序
           // 注意：原始数组是 int[]，需要转换为 Integer[] 才能使用 Collections.reverseOrder()
           Integer[] sortedCoins = Arrays.stream(coins).boxed().toArray(Integer[]::new);
           Arrays.sort(sortedCoins, Collections.reverseOrder());
   
           System.out.println("Amount: " + amount + ", Coins: " + Arrays.toString(coins));
           System.out.println("Coins used:");
   
           int totalCoins = 0;
           Map<Integer, Integer> coinCount = new HashMap<>(); // 记录每种硬币的使用数量
   
           for (int coin : sortedCoins) {
               while (amount >= coin) {
                   amount -= coin;
                   totalCoins++;
                   coinCount.put(coin, coinCount.getOrDefault(coin, 0) + 1);
               }
           }
   
           // 打印使用情况
           for (Map.Entry<Integer, Integer> entry : coinCount.entrySet()) {
               System.out.println(entry.getKey() + " x " + entry.getValue());
           }
   
           if (amount == 0) { // 如果最终金额为 0，表示成功凑成
               return totalCoins;
           } else { // 否则，无法凑成
               System.out.println("Cannot make exact change with given coins.");
               return -1;
           }
       }
   
       public static void main(String[] args) {
           int[] coins1 = {100, 50, 20, 10, 5, 1};
           int amount1 = 137;
           int result1 = greedyCoinChange(coins1, amount1);
           System.out.println("Total coins: " + result1); // Expected: 5 (1x100, 1x20, 1x10, 1x5, 2x1)
   
           System.out.println("\n--- Another Test Case ---");
           int[] coins2 = {1, 5, 10, 25}; // US Coin system
           int amount2 = 63;
           int result2 = greedyCoinChange(coins2, amount2);
           System.out.println("Total coins: " + result2); // Expected: 63 = 2x25 + 1x10 + 1x5 + 3x1 = 4+1+1+3 = 9 coins
   
           System.out.println("\n--- Test case where greedy fails (should warn in description) ---");
           // 注意：对于以下情况，贪心算法无法给出最优解。
           // 最佳答案应该是 3 + 3 = 2 个硬币
           // 贪心算法会给出 4 + 1 + 1 = 3 个硬币
           // 因此，此类题目通常会在描述中注明硬币系统特性
           int[] coins3 = {1, 3, 4};
           int amount3 = 6;
           System.out.println("Warning: For {1,3,4} and amount 6, greedy might not be optimal (expected 2, got 3).");
           int result3 = greedyCoinChange(coins3, amount3);
           System.out.println("Total coins: " + result3); // Expected (by greedy): 3 (4+1+1)
       }
   }
   ```