## 36. 函数式编程进阶 (Advanced Functional Programming)

### 36.1. 自定义 `Collector` (Custom `Collector`)

- **知识点：** `Stream` API 的 `collect()` 方法；`Collector` 接口的组成 (`supplier`, `accumulator`, `combiner`, `finisher`, `characteristics`)；实现自定义 `Collector` 以执行特定聚合操作。

1. **题目名称：** 收集字符串并按长度分组 **题目描述：**

   - 编写一个自定义 `Collector`，将 `List<String>` 中的字符串按照它们的长度进行分组。
   - 最终结果应该是一个 `Map<Integer, List<String>>`，其中键是字符串的长度，值是该长度的所有字符串列表。
   - 在 `main` 方法中，使用你的自定义 `Collector` 处理一个字符串列表，并打印结果。 **输入示例：** `["apple", "banana", "cat", "dog", "elephant", "frog", "grape"]` **输出示例：**

   ```
   {3=[cat, dog], 4=[frog], 5=[apple, grape], 6=[banana], 8=[elephant]}
   ```

   **参考代码结构：**

   **`GroupByLengthCollector.java`**

​    import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set; import java.util.function.BiConsumer; import java.util.function.BinaryOperator; import java.util.function.Function; import java.util.function.Supplier; import java.util.stream.Collector;



````
public class GroupByLengthCollector implements Collector<String, Map<Integer, List<String>>, Map<Integer, List<String>>> {

    @Override
    public Supplier<Map<Integer, List<String>>> supplier() {
        // 在这里实现容器的供应器
        return HashMap::new; // 初始结果容器
    }

    @Override
    public BiConsumer<Map<Integer, List<String>>, String> accumulator() {
        // 在这里实现累加器，将单个元素添加到容器中
        return (map, s) -> {
            map.computeIfAbsent(s.length(), k -> new ArrayList<>()).add(s);
        };
    }

    @Override
    public BinaryOperator<Map<Integer, List<String>>> combiner() {
        // 在这里实现合并器，将两个部分结果容器合并
        return (map1, map2) -> {
            map2.forEach((len, list) -> map1.merge(len, list, (existingList, newList) -> {
                existingList.addAll(newList);
                return existingList;
            }));
            return map1;
        };
    }

    @Override
    public Function<Map<Integer, List<String>>, Map<Integer, List<String>>> finisher() {
        // 在这里实现最终器 (可选)，对最终结果进行转换
        // 这里我们不需要进一步转换，所以直接返回Identity
        return Function.identity();
    }

    @Override
    public Set<Characteristics> characteristics() {
        // 定义Collector的特性 (例如是否支持并发)
        return Collections.emptySet(); // 默认为顺序处理，不保证顺序，不并列
        // 如果希望并发，可以添加 Characteristics.CONCURRENT
    }

    // 静态工厂方法，方便使用
    public static GroupByLengthCollector groupByLength() {
        return new GroupByLengthCollector();
    }
}
```

**`Main.java`**
```java
import java.util.Arrays;
import java.util.List;
import java.util.Map;

public class CustomCollectorDemo {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("apple", "banana", "cat", "dog", "elephant", "frog", "grape");

        // 使用自定义 Collector
        Map<Integer, List<String>> groupedByLength = words.stream()
                                                        .collect(GroupByLengthCollector.groupByLength());

        System.out.println("Grouped by length: " + groupedByLength);

        // 作为对比，使用 Collectors.groupingBy
        Map<Integer, List<String>> groupedByLengthBuiltIn = words.stream()
                                                                .collect(java.util.stream.Collectors.groupingBy(String::length));
        System.out.println("Grouped by length (Built-in): " + groupedByLengthBuiltIn);
    }
}
```
````
