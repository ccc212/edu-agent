## 26. 设计模式进阶 (Advanced Design Patterns)

### 26.1. 观察者模式 (Observer Pattern)

- **知识点：** 观察者模式的目的（定义对象间一对多的依赖关系，当一个对象状态改变时，所有依赖它的对象都会得到通知并自动更新）；主题 (Subject) / 被观察者；观察者 (Observer)；推/拉模型。

1. **题目名称：** 消息通知系统 **题目描述：**

   - 模拟一个简单的消息通知系统。
   - 定义 `Subject` 接口（被观察者）和 `Observer` 接口（观察者）。
   - 实现一个 `ConcreteSubject` 类，它可以注册、移除观察者，并在状态改变时通知所有注册的观察者。
   - 实现 `UserObserver` 类，作为具体的观察者，当收到通知时打印消息。
   - 在 `main` 方法中，创建 `ConcreteSubject` 实例，注册多个 `UserObserver`，然后改变 `ConcreteSubject` 的状态，观察所有观察者是否都收到了通知。 **参考代码结构：**

   **`Subject.java`**

   ```java
   import java.util.ArrayList;
   import java.util.List;
   
   // Subject (被观察者) 接口
   interface Subject {
       void registerObserver(Observer o);
       void removeObserver(Observer o);
       void notifyObservers();
   }
   
   // Observer (观察者) 接口
   interface Observer {
       void update(String message);
   }
   
   // ConcreteSubject (具体被观察者)
   class MessagePublisher implements Subject {
       private List<Observer> observers = new ArrayList<>();
       private String message;
   
       public void setMessage(String message) {
           this.message = message;
           notifyObservers(); // 状态改变时通知观察者
       }
   
       @Override
       public void registerObserver(Observer o) {
           observers.add(o);
           System.out.println("Observer registered: " + o.getClass().getSimpleName());
       }
   
       @Override
       public void removeObserver(Observer o) {
           observers.remove(o);
           System.out.println("Observer removed: " + o.getClass().getSimpleName());
       }
   
       @Override
       public void notifyObservers() {
           System.out.println("\nNotifying observers about message change: \"" + message + "\"");
           for (Observer observer : observers) {
               observer.update(message);
           }
       }
   }
   
   // ConcreteObserver (具体观察者)
   class User implements Observer {
       private String name;
   
       public User(String name) {
           this.name = name;
       }
   
       @Override
       public void update(String message) {
           System.out.println(name + " received message: " + message);
       }
   }
   
   // Main.java
   public class ObserverPatternDemo {
       public static void main(String[] args) {
           MessagePublisher publisher = new MessagePublisher();
   
           User user1 = new User("Alice");
           User user2 = new User("Bob");
           User user3 = new User("Charlie");
   
           publisher.registerObserver(user1);
           publisher.registerObserver(user2);
   
           publisher.setMessage("Today's special offer!");
           publisher.setMessage("Important system update!");
   
           publisher.removeObserver(user2);
           publisher.registerObserver(user3);
   
           publisher.setMessage("Final announcement of the day.");
       }
   }
   ```

### 26.2. 策略模式 (Strategy Pattern)

- **知识点：** 策略模式的目的（定义一系列算法，将它们封装起来，并且使它们可以相互替换）；上下文 (Context)；策略接口 (Strategy Interface)；具体策略 (Concrete Strategy)。

1. **题目名称：** 订单折扣计算 **题目描述：**

   - 模拟一个电商系统的订单折扣计算。
   - 定义一个 `DiscountStrategy` 接口，包含一个 `applyDiscount(double amount)` 方法。
   - 实现不同的具体折扣策略，例如 `PercentageDiscountStrategy` (按百分比折扣) 和 `FixedAmountDiscountStrategy` (固定金额折扣)。
   - 定义一个 `Order` 类作为上下文，它持有一个 `DiscountStrategy` 实例，并提供一个 `checkout(double totalAmount)` 方法来计算最终价格。
   - 在 `main` 方法中，创建 `Order` 实例，并动态设置不同的折扣策略，计算并打印最终价格。 **参考代码结构：**

   **`DiscountStrategy.java`**

   ```java
   // 策略接口
   interface DiscountStrategy {
       double applyDiscount(double amount);
   }
   
   // 具体策略1: 百分比折扣
   class PercentageDiscountStrategy implements DiscountStrategy {
       private double percentage; // 例如 0.10 表示 10%
   
       public PercentageDiscountStrategy(double percentage) {
           this.percentage = percentage;
       }
   
       @Override
       public double applyDiscount(double amount) {
           return amount * (1 - percentage);
       }
   }
   
   // 具体策略2: 固定金额折扣
   class FixedAmountDiscountStrategy implements DiscountStrategy {
       private double fixedAmount;
   
       public FixedAmountDiscountStrategy(double fixedAmount) {
           this.fixedAmount = fixedAmount;
       }
   
       @Override
       public double applyDiscount(double amount) {
           return Math.max(0, amount - fixedAmount); // 确保折扣后金额不为负
       }
   }
   
   // 上下文
   class Order {
       private DiscountStrategy discountStrategy;
   
       public void setDiscountStrategy(DiscountStrategy discountStrategy) {
           this.discountStrategy = discountStrategy;
       }
   
       public double checkout(double totalAmount) {
           if (discountStrategy == null) {
               System.out.println("No discount strategy applied.");
               return totalAmount;
           }
           double finalAmount = discountStrategy.applyDiscount(totalAmount);
           System.out.println("Total amount: " + totalAmount + ", Final amount after discount: " + finalAmount);
           return finalAmount;
       }
   }
   
   // Main.java
   public class StrategyPatternDemo {
       public static void main(String[] args) {
           Order order = new Order();
           double originalAmount = 100.0;
   
           // 使用百分比折扣
           order.setDiscountStrategy(new PercentageDiscountStrategy(0.10)); // 10% off
           order.checkout(originalAmount);
   
           // 使用固定金额折扣
           order.setDiscountStrategy(new FixedAmountDiscountStrategy(20.0)); // $20 off
           order.checkout(originalAmount);
   
           // 不使用折扣
           order.setDiscountStrategy(null);
           order.checkout(originalAmount);
   
           // 多个折扣叠加 (可以考虑扩展，但这超出了基础策略模式)
           // order.setDiscountStrategy(new FixedAmountDiscountStrategy(5.0)); // 再减5
           // order.checkout(order.checkout(originalAmount)); // 示例：错误的使用方式，应该设计新的组合策略
       }
   }
   ```
