## 42. 动态规划 (Dynamic Programming)

### 42.1. 斐波那契数列与记忆化 (Fibonacci Sequence & Memoization)

- **知识点：** 动态规划的基本思想 (重叠子问题、最优子结构)；自顶向下 (Top-Down) 的记忆化搜索；自底向上 (Bottom-Up) 的递推。

1. **题目名称：** 斐波那契数列 (优化版) **题目描述：** 斐波那契数列是一个经典的数列，其中每个数字是前两个数字的和，从 0 和 1 开始：0, 1, 1, 2, 3, 5, 8, ...

   - 实现一个静态方法 `fibonacci(int n)`，计算第 `n` 个斐波那契数（`n` 从 0 开始计数）。
   - 使用动态规划的两种方法实现：
     - **方法一：记忆化搜索 (Memoization)**：使用数组或 HashMap 存储已计算的结果，避免重复计算。
     - **方法二：自底向上 (Tabulation)**：使用循环和数组从下往上填充结果。
   - 在 `main` 方法中，分别测试两种方法计算前几个斐波那契数，并比较它们相对于纯递归的效率（可选）。 **输入示例：** `n = 7` **输出示例：**

   ```
   Fibonacci (Memoization) for n=7: 13
   Fibonacci (Tabulation) for n=7: 13
   ```

   **知识点描述：**

   - **重叠子问题：** 计算 `fib(n)` 需要 `fib(n-1)` 和 `fib(n-2)`，这些子问题在计算过程中会被多次重复计算。
   - **最优子结构：** `fib(n)` 的最优解（自身）可以通过 `fib(n-1)` 和 `fib(n-2)` 的最优解组合得到。
   - **记忆化：** 存储子问题的解，避免重复计算。
   - **递推：** 从基础情况开始，逐步计算出更大的子问题，直到最终解。
   - **时间复杂度：** O(N)。
   - **空间复杂度：** O(N) (记忆化/递推数组) 或 O(1) (滚动数组优化)。

   **参考代码结构：**

   ```java
   import java.util.Arrays;
   import java.util.HashMap;
   import java.util.Map;
   
   public class FibonacciDP {
   
       // 方法一：记忆化搜索 (Top-Down)
       private static Map<Integer, Integer> memo = new HashMap<>();
   
       public static int fibonacciMemoization(int n) {
           if (n < 0) {
               throw new IllegalArgumentException("Input must be non-negative.");
           }
           if (n == 0) return 0;
           if (n == 1) return 1;
           if (memo.containsKey(n)) {
               return memo.get(n);
           }
   
           int result = fibonacciMemoization(n - 1) + fibonacciMemoization(n - 2);
           memo.put(n, result);
           return result;
       }
   
       // 方法二：自底向上 (Tabulation)
       public static int fibonacciTabulation(int n) {
           if (n < 0) {
               throw new IllegalArgumentException("Input must be non-negative.");
           }
           if (n == 0) return 0;
           if (n == 1) return 1;
   
           int[] dp = new int[n + 1];
           dp[0] = 0;
           dp[1] = 1;
           for (int i = 2; i <= n; i++) {
               dp[i] = dp[i - 1] + dp[i - 2];
           }
           return dp[n];
       }
   
       // 方法二优化：自底向上 (Tabulation with O(1) space)
       public static int fibonacciTabulationOptimized(int n) {
           if (n < 0) {
               throw new IllegalArgumentException("Input must be non-negative.");
           }
           if (n == 0) return 0;
           if (n == 1) return 1;
   
           int a = 0; // f(i-2)
           int b = 1; // f(i-1)
           int result = 0;
           for (int i = 2; i <= n; i++) {
               result = a + b;
               a = b;
               b = result;
           }
           return result;
       }
   
   
       public static void main(String[] args) {
           int n = 7;
   
           // 清除上次运行的memo (因为memo是静态的)
           memo.clear();
           System.out.println("Fibonacci (Memoization) for n=" + n + ": " + fibonacciMemoization(n));
   
           System.out.println("Fibonacci (Tabulation) for n=" + n + ": " + fibonacciTabulation(n));
   
           System.out.println("Fibonacci (Tabulation Optimized) for n=" + n + ": " + fibonacciTabulationOptimized(n));
   
           System.out.println("\nTesting other values:");
           for (int i = 0; i <= 10; i++) {
               memo.clear(); // 每次测试前清空memo
               System.out.println("F(" + i + ") = " + fibonacciTabulationOptimized(i));
           }
       }
   }
   ```

### 42.2. 背包问题 (Knapsack Problem)

- **知识点：** 0/1 背包问题；动态规划解决思路（`dp[i][w]` 表示前 `i` 个物品，背包容量为 `w` 时的最大价值）；状态转移方程。

1. **题目名称：** 0/1 背包问题 **题目描述：** 给你一个可装载最大重量为 `W` 的背包和 `n` 个物品，每个物品都有重量 `weights[i]` 和对应的价值 `values[i]`。每件物品只能用一次，问你能装入背包的最大总价值。

   - 实现一个静态方法 `knapsack01(int W, int[] weights, int[] values)`。
   - 在 `main` 方法中，用一个示例测试你的实现，并打印最大价值。 **输入示例：**

   ```
   W = 10 (背包容量)
   weights = {2, 3, 4, 5}
   values = {3, 4, 5, 6}
   ```

   **输出示例：**

   ```
   Maximum value for knapsack: 10
   (选择物品 2 (重3, 值4) 和 4 (重5, 值6)，总重8，总值10)
   ```

   **知识点描述：**

   - **状态定义：** `dp[i][j]` 表示前 `i` 个物品，背包容量为 `j` 时能获得的最大价值。
   - 状态转移方程：
     - 如果第 `i` 个物品的重量 `weights[i-1]` 大于当前背包容量 `j`：`dp[i][j] = dp[i-1][j]` (不选择第 `i` 个物品)
     - 如果第 `i` 个物品的重量 `weights[i-1]` 小于等于当前背包容量 `j`： `dp[i][j] = max(dp[i-1][j], values[i-1] + dp[i-1][j - weights[i-1]])` (不选择或选择第 `i` 个物品)
   - **边界条件：** `dp[0][j] = 0` (没有物品)，`dp[i][0] = 0` (背包容量为0)。
   - **时间复杂度：** O(N⋅W)。
   - **空间复杂度：** O(N⋅W)，可优化为 O(W) (滚动数组)。

   **参考代码结构：**

   ```java
   public class KnapsackProblem {
   
       // 0/1 背包问题
       public static int knapsack01(int W, int[] weights, int[] values) {
           int n = weights.length; // 物品的数量
   
           // dp[i][w] 表示前 i 个物品，背包容量为 w 时的最大价值
           int[][] dp = new int[n + 1][W + 1];
   
           // 填充 dp 表
           for (int i = 1; i <= n; i++) { // 遍历物品
               for (int w = 1; w <= W; w++) { // 遍历背包容量
                   // 当前物品的重量和价值 (注意数组索引与物品编号的对应关系)
                   int currentWeight = weights[i - 1];
                   int currentValue = values[i - 1];
   
                   if (currentWeight > w) {
                       // 如果当前物品的重量大于背包容量，则不能放入，价值等于不放这个物品时的价值
                       dp[i][w] = dp[i - 1][w];
                   } else {
                       // 可以选择放入或不放入
                       // 不放入：dp[i-1][w]
                       // 放入：currentValue + dp[i-1][w - currentWeight]
                       dp[i][w] = Math.max(dp[i - 1][w], currentValue + dp[i - 1][w - currentWeight]);
                   }
               }
           }
           return dp[n][W]; // 返回所有物品，背包容量为 W 时的最大价值
       }
   
       // 优化空间复杂度到 O(W) 的 0/1 背包问题
       public static int knapsack01Optimized(int W, int[] weights, int[] values) {
           int n = weights.length;
           int[] dp = new int[W + 1]; // dp[w] 表示当前容量 w 的最大价值
   
           for (int i = 0; i < n; i++) { // 遍历物品
               int currentWeight = weights[i];
               int currentValue = values[i];
               // 从后往前遍历背包容量，确保每个物品只被考虑一次
               for (int w = W; w >= currentWeight; w--) {
                   dp[w] = Math.max(dp[w], currentValue + dp[w - currentWeight]);
               }
           }
           return dp[W];
       }
   
       public static void main(String[] args) {
           int W = 10;
           int[] weights = {2, 3, 4, 5};
           int[] values = {3, 4, 5, 6};
   
           int maxVal = knapsack01(W, weights, values);
           System.out.println("Maximum value for knapsack (2D DP): " + maxVal); // Expected: 10
   
           int maxValOptimized = knapsack01Optimized(W, weights, values);
           System.out.println("Maximum value for knapsack (1D DP optimized): " + maxValOptimized); // Expected: 10
   
           // 另一个测试用例
           int W2 = 50;
           int[] weights2 = {10, 20, 30};
           int[] values2 = {60, 100, 120};
           System.out.println("Maximum value for knapsack (W=50): " + knapsack01(W2, weights2, values2)); // Expected: 220 (10+20=30, 60+100=160; 20+30=50, 100+120=220)
       }
   }
   ```
