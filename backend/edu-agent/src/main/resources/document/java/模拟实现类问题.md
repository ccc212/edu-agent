## 58. 模拟 / 实现类问题 (Simulation / Implementation Problems)

### 58.1. 实现循环队列 (Circular Queue)

- **知识点：** 队列 (Queue)；数组实现；循环数组；判空和判满条件。

1. **题目名称：** 设计循环队列 **题目描述：** 设计你的循环队列实现。循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。

    - 实现

      ```
      MyCircularQueue
      ```

      类：

        - `MyCircularQueue(int k)` 构造器：初始化队列的大小为 `k`。
        - `boolean enQueue(int value)`：将一个元素插入队列。如果成功插入则返回 `true`。
        - `boolean deQueue()`：从队列中删除一个元素。如果成功删除则返回 `true`。
        - `int Front()`：从队首获取元素。如果队列为空，返回 -1。
        - `int Rear()`：获取队尾元素。如果队列为空，返回 -1。
        - `boolean isEmpty()`：检查队列是否为空。
        - `boolean isFull()`：检查队列是否已满。

    - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例 (操作序列)：**

   ```
   MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置容量为 3
   circularQueue.enQueue(1);  // 返回 true
   circularQueue.enQueue(2);  // 返回 true
   circularQueue.enQueue(3);  // 返回 true
   circularQueue.enQueue(4);  // 返回 false，队列已满
   circularQueue.Rear();      // 返回 3
   circularQueue.isFull();    // 返回 true
   circularQueue.deQueue();   // 返回 true
   circularQueue.enQueue(4);  // 返回 true
   circularQueue.Rear();      // 返回 4
   ```



**输出示例：**





   ```
   New Circular Queue with capacity 3
   Enqueue 1: true. Queue: [1, _, _], F:0, R:1
   Enqueue 2: true. Queue: [1, 2, _], F:0, R:2
   Enqueue 3: true. Queue: [1, 2, 3], F:0, R:0
   Enqueue 4: false. Queue is full.
   Rear: 3
   Is Full: true
   Dequeue: true. Queue: [_, 2, 3], F:1, R:0
   Enqueue 4: true. Queue: [4, 2, 3], F:1, R:1
   Rear: 4
   ```

**知识点描述：**

- **数组实现：** 通常使用固定大小的数组来实现循环队列。

- **两个指针：** `front` 指针指向队首元素，`rear` 指针指向队尾元素的下一个空位置。

- **循环特性：** 当指针到达数组末尾时，通过取模运算 (`% capacity`) 回到数组开头。

- **判空：** 当 `front == rear` 时，队列为空。

- 判满：

  当

  ```
  (rear + 1) % capacity == front
  ```

  时，队列为满。注意，为了区分空和满，通常会牺牲一个数组单元，即

  ```
  capacity
  ```

  为

  ```
  k
  ```

  的队列实际只能存储

  ```
  k
  ```

  个元素，但数组大小是

  ```
  k+1
  ```

  （或者在数组大小为

  ```
  k
  ```

  的情况下，通过计数器来判断）。本题目采用后者，即数组大小为

  ```
  k
  ```

  ，使用计数器或通过

  ```
  (rear + 1) % k == front
  ```

  和

  ```
  count
  ```

  来判断。

    - 如果使用

      ```
      count
      ```

      来判断：

        - `isEmpty()`: `count == 0`
        - `isFull()`: `count == k`

    - 如果仅使用

      ```
      front
      ```

      和

      ```
      rear
      ```

      指针（

      本题采用此种方法，需要注意判满条件

      ）：

        - `front` 指向队列的第一个元素。
        - `rear` 指向队列最后一个元素的下一个位置。
        - 当 `front == rear` 时队列为空。
        - 当 `(rear + 1) % k == front` 时队列为满。这意味着队列中总有一个空位（即 `k` 个元素需要 `k+1` 个物理空间才能通过这种方式判断满，或者 `k` 个物理空间实际只能存 `k-1` 个元素）。为了更直观地实现 `k` 容量，通常会使用一个 `size` 或 `count` 变量。
        - **更常见的实现 (本示例采用):** `front` 指向队首元素，`rear` 指向队尾元素。当 `front == -1` (或 `head == tail` 且 `count == 0`) 为空；当 `count == capacity` 为满。

- **时间复杂度：** 所有操作都是 O(1)。

- **空间复杂度：** O(k) (存储队列元素)。

**参考代码结构：**

   ```java
   import java.util.Arrays;
   
   class MyCircularQueue {
       private int[] data;
       private int head; // 队首元素的索引
       private int tail; // 队尾元素的索引
       private int size;   // 当前队列中的元素数量
       private int capacity; // 队列容量
   
       public MyCircularQueue(int k) {
           this.capacity = k;
           this.data = new int[k];
           this.head = -1; // 初始化为 -1 表示队列为空
           this.tail = -1; // 初始化为 -1 表示队列为空
           this.size = 0;
           System.out.println("New Circular Queue with capacity " + k);
       }
   
       public boolean enQueue(int value) {
           if (isFull()) {
               System.out.println("Enqueue " + value + ": false. Queue is full.");
               return false;
           }
           if (isEmpty()) { // 队列为空时，头尾指针都指向第一个元素
               head = 0;
           }
           tail = (tail + 1) % capacity; // 尾指针前进
           data[tail] = value;
           size++;
           printQueueStatus("Enqueue " + value + ": true.");
           return true;
       }
   
       public boolean deQueue() {
           if (isEmpty()) {
               System.out.println("Dequeue: false. Queue is empty.");
               return false;
           }
           if (head == tail) { // 队列中只剩一个元素
               head = -1;
               tail = -1;
           } else {
               head = (head + 1) % capacity; // 头指针前进
           }
           size--;
           printQueueStatus("Dequeue: true.");
           return true;
       }
   
       public int Front() {
           if (isEmpty()) {
               System.out.println("Front: -1 (empty)");
               return -1;
           }
           System.out.println("Front: " + data[head]);
           return data[head];
       }
   
       public int Rear() {
           if (isEmpty()) {
               System.out.println("Rear: -1 (empty)");
               return -1;
           }
           System.out.println("Rear: " + data[tail]);
           return data[tail];
       }
   
       public boolean isEmpty() {
           boolean empty = (size == 0);
           if (empty) System.out.println("Is Empty: true");
           else System.out.println("Is Empty: false");
           return empty;
       }
   
       public boolean isFull() {
           boolean full = (size == capacity);
           if (full) System.out.println("Is Full: true");
           else System.out.println("Is Full: false");
           return full;
       }
   
       private void printQueueStatus(String action) {
           StringBuilder sb = new StringBuilder();
           sb.append(action).append(" Queue: [");
           if (size == 0) {
               for (int i = 0; i < capacity; i++) {
                   sb.append("_, ");
               }
           } else {
               for (int i = 0; i < capacity; i++) {
                   if (i == head) {
                       sb.append("F");
                   }
                   if (i == tail) {
                       sb.append("R");
                   }
                   if (head == -1) { // 初始状态为空
                       sb.append("_, ");
                   } else if (isIndexInQueue(i)) {
                        sb.append(data[i]);
                   } else {
                       sb.append("_");
                   }
                   sb.append(", ");
               }
           }
           sb.setLength(sb.length() - 2); // 移除最后的 ", "
           sb.append("], F:").append(head).append(", R:").append(tail);
           System.out.println(sb.toString());
       }
   
       // 辅助方法：判断索引 i 是否在当前队列的有效范围内
       private boolean isIndexInQueue(int i) {
           if (head == -1) return false;
           if (head <= tail) {
               return i >= head && i <= tail;
           } else { // 队列循环了
               return i >= head || i <= tail;
           }
       }
   }
   
   public class MainCircularQueue {
       public static void main(String[] args) {
           MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置容量为 3
           circularQueue.enQueue(1);  // 返回 true
           circularQueue.enQueue(2);  // 返回 true
           circularQueue.enQueue(3);  // 返回 true
           circularQueue.enQueue(4);  // 返回 false，队列已满
           circularQueue.Rear();      // 返回 3
           circularQueue.isFull();    // 返回 true
           circularQueue.deQueue();   // 返回 true
           circularQueue.enQueue(4);  // 返回 true
           circularQueue.Rear();      // 返回 4
   
           System.out.println("\n--- Another Test Case ---");
           MyCircularQueue cq2 = new MyCircularQueue(2);
           cq2.enQueue(10);
           cq2.deQueue();
           cq2.deQueue(); // Should be false
           cq2.enQueue(20);
           cq2.enQueue(30);
           cq2.enQueue(40); // Should be false
           cq2.Front();
           cq2.Rear();
       }
   }
   ```

### 58.2. 有效的括号 (Valid Parentheses)

- **知识点：** 栈 (Stack)；括号匹配；LIFO 原则。

1. **题目名称：** 有效的括号 **题目描述：** 给定一个只包括 `(`, `)`, `{`, `}`, `[`, `]` 的字符串 `s`，判断字符串是否有效。 有效字符串需满足：

    1. 左括号必须用相同类型的右括号闭合。
    2. 左括号必须以正确的顺序闭合。
    3. 每个右括号都有一个对应的相同类型的左括号。

    - 实现一个静态方法 `isValid(String s)`。
    - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   s = "({[]})"
   ```

   **输出示例：**

   ```
   String "({[]})": true
   ```

   **知识点描述：**

    - **核心思想：** 使用栈来解决括号匹配问题。栈的 LIFO（后进先出）特性天然适合处理嵌套和顺序匹配。

    - 操作：

        1. 遍历输入字符串的每个字符。

        2. 如果遇到左括号 `(`, `{`, `[`，将其压入栈中。

        3. 如果遇到右括号

           ```
           )
           ```

           ,

           ```
           }
           ```

           ,

           ```
           ]
           ```

           ：

            - 检查栈是否为空。如果为空，说明没有对应的左括号，直接返回 `false`。
            - 从栈顶弹出一个左括号。
            - 判断弹出的左括号是否与当前右括号类型匹配。如果不匹配，返回 `false`。

        4. 字符串遍历结束后，检查栈是否为空。如果栈为空，说明所有括号都成功匹配；否则，说明有未闭合的左括号，返回 `false`。

    - **时间复杂度：** O(N) (N 是字符串长度)，因为每个字符只遍历一次，栈操作是 O(1)。

    - **空间复杂度：** O(N) (最坏情况下，所有字符都是左括号，栈的大小为 N)。

   **参考代码结构：**

   ```java
   import java.util.Stack;
   import java.util.HashMap;
   import java.util.Map;
   
   public class ValidParentheses {
   
       public static boolean isValid(String s) {
           // 使用 HashMap 存储括号的映射关系
           Map<Character, Character> mappings = new HashMap<>();
           mappings.put(')', '(');
           mappings.put('}', '{');
           mappings.put(']', '[');
   
           Stack<Character> stack = new Stack<>();
   
           for (char c : s.toCharArray()) {
               if (mappings.containsKey(c)) { // 当前字符是右括号
                   char topElement = stack.empty() ? '#' : stack.pop(); // 如果栈为空，用一个特殊字符占位
   
                   if (topElement != mappings.get(c)) { // 检查栈顶元素是否与当前右括号匹配
                       System.out.println("String \"" + s + "\": false (mismatch or empty stack for closing " + c + ")");
                       return false;
                   }
               } else { // 当前字符是左括号，压入栈中
                   stack.push(c);
               }
           }
   
           // 遍历结束后，如果栈为空，说明所有括号都成功匹配
           boolean result = stack.empty();
           System.out.println("String \"" + s + "\": " + result);
           return result;
       }
   
       public static void main(String[] args) {
           isValid("()");      // true
           isValid("()[]{}");  // true
           isValid("({[]})");  // true
           isValid("(]");      // false
           isValid("([)]");    // false
           isValid("{[]}");    // true
           isValid("");        // true (空字符串是有效的)
           isValid("[");       // false
           isValid("]");       // false
       }
   }
   ```