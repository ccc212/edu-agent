## 35. 结构化并发 (Structured Concurrency) (Java 21+)

### 35.1. `StructuredTaskScope` (`StructuredTaskScope`)

- **知识点：** 结构化并发的引入与目的（简化并发编程，提高代码可读性和可维护性，确保所有子任务在父任务结束前终止）；`StructuredTaskScope` 类；`fork()` (启动子任务)；`join()` (等待子任务完成)；`throwIfFailed()` (聚合子任务异常)；`ShutdownOnFailure`, `ShutdownOnSuccess` 等子类。
- **注意：** 结构化并发是 Java 21 的预览特性（在 Java 19/20 中是孵化特性）。

1. **题目名称：** 并行执行多个子任务并处理结果或失败 **题目描述：**

   - 模拟两个独立的子任务：

     - `fetchUserPreferences()`：模拟获取用户偏好设置（成功返回 `String`，模拟延迟 500ms）。
     - `fetchLatestNews()`：模拟获取最新新闻（可能成功返回 `String`，也可能模拟失败抛出异常，模拟延迟 800ms）。

   - 使用 

     ```
     StructuredTaskScope.ShutdownOnFailure
     ```

      来管理这两个任务：

     - 如果任何一个子任务失败，则整个作用域内的其他任务应该被取消，并抛出异常。
     - 如果两个任务都成功，则聚合它们的结果并打印。

   - 在 `main` 方法中，分别测试成功和失败两种场景。 **参考代码结构：**

   **`TaskSimulation.java` (辅助类)**

   ```java
   import java.util.concurrent.Callable;
   import java.util.concurrent.TimeUnit;
   
   class TaskSimulation {
       public static Callable<String> fetchUserPreferences() {
           return () -> {
               System.out.println(Thread.currentThread().getName() + ": Fetching user preferences...");
               TimeUnit.MILLISECONDS.sleep(500); // 模拟延迟
               System.out.println(Thread.currentThread().getName() + ": User preferences fetched.");
               return "UserPrefs: DarkMode, NotificationsOn";
           };
       }
   
       public static Callable<String> fetchLatestNews(boolean simulateFailure) {
           return () -> {
               System.out.println(Thread.currentThread().getName() + ": Fetching latest news...");
               TimeUnit.MILLISECONDS.sleep(800); // 模拟延迟
               if (simulateFailure) {
                   System.out.println(Thread.currentThread().getName() + ": Simulating news fetch failure.");
                   throw new RuntimeException("Failed to fetch latest news!");
               }
               System.out.println(Thread.currentThread().getName() + ": Latest news fetched.");
               return "News: Top headlines are out!";
           };
       }
   }
   ```

   **`StructuredConcurrencyDemo.java`**

   ```java
   import java.util.concurrent.StructuredTaskScope;
   import java.util.concurrent.Future;
   import java.util.concurrent.ExecutionException;
   
   public class StructuredConcurrencyDemo {
   
       public static void main(String[] args) {
           // Scenario 1: All tasks succeed
           System.out.println("--- Scenario 1: All tasks succeed ---");
           try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
               Future<String> preferencesFuture = scope.fork(TaskSimulation.fetchUserPreferences());
               Future<String> newsFuture = scope.fork(TaskSimulation.fetchLatestNews(false)); // 不模拟失败
   
               scope.join(); // 等待所有子任务完成
               scope.throwIfFailed(); // 如果有任务失败，则抛出异常
   
               String preferences = preferencesFuture.resultNow();
               String news = newsFuture.resultNow();
               System.out.println("Result: Preferences [" + preferences + "], News [" + news + "]");
   
           } catch (InterruptedException e) {
               Thread.currentThread().interrupt();
               System.err.println("Main thread interrupted: " + e.getMessage());
           } catch (ExecutionException e) { // 捕获由 throwIfFailed 抛出的异常
               System.err.println("One or more tasks failed: " + e.getCause().getMessage());
           }
   
           System.out.println("\n--- Scenario 2: One task fails ---");
           // Scenario 2: One task fails (news fetch fails)
           try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
               Future<String> preferencesFuture = scope.fork(TaskSimulation.fetchUserPreferences());
               Future<String> newsFuture = scope.fork(TaskSimulation.fetchLatestNews(true)); // 模拟失败
   
               scope.join();
               scope.throwIfFailed(); // 预期会在这里抛出 ExecutionException
   
               // 如果代码执行到这里，说明没有异常，但不应该发生
               String preferences = preferencesFuture.resultNow();
               String news = newsFuture.resultNow();
               System.out.println("Result: Preferences [" + preferences + "], News [" + news + "]");
   
           } catch (InterruptedException e) {
               Thread.currentThread().interrupt();
               System.err.println("Main thread interrupted: " + e.getMessage());
           } catch (ExecutionException e) {
               System.err.println("Caught expected exception: " + e.getCause().getMessage());
               // 此时，preferencesFuture 可能已经完成或被取消，需要检查其状态
               // System.out.println("Preferences Future done: " + preferencesFuture.isDone());
               // System.out.println("Preferences Future cancelled: " + preferencesFuture.isCancelled());
               // System.out.println("News Future done: " + newsFuture.isDone());
               // System.out.println("News Future cancelled: " + newsFuture.isCancelled());
           }
       }
   }
   ```
