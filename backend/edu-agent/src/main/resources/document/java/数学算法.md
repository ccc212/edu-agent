## 46. 数学算法 (Mathematical Algorithms)

### 46.1. 数论 (Number Theory)

- **知识点：** 质数 (Prime Number)；最大公约数 (GCD)；最小公倍数 (LCM)；欧几里得算法。

1. **题目名称：** 判断质数与生成质数 (Sieve of Eratosthenes) **题目描述：**

   - **部分 A：** 实现一个静态方法 `isPrime(int n)`，判断一个正整数 `n` 是否是质数（只能被 1 和自身整除的自然数，1 不是质数）。
   - **部分 B：** 实现一个静态方法 `sieveOfEratosthenes(int limit)`，使用埃拉托斯特尼筛法找出小于等于 `limit` 的所有质数，并返回一个布尔数组，其中 `true` 表示对应索引是质数。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   n = 17
   limit = 30
   ```

   **输出示例：**

   ```
   Is 17 a prime number? true
   Is 15 a prime number? false
   Primes up to 30: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
   ```

   **知识点描述：**

   - **质数判断：** 暴力法是逐一尝试除以 2 到 `sqrt(n)` 之间的所有数。
   - **埃拉托斯特尼筛法：** 从 2 开始，将所有倍数标记为合数。未被标记的数字就是质数。
   - 时间复杂度：
     - `isPrime`: O(N![img](data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z"></path></svg>))。
     - `sieveOfEratosthenes`: O(NloglogN) (非常高效)。
   - **空间复杂度：** O(1) (`isPrime`) 或 O(N) (`sieveOfEratosthenes`)。

   **参考代码结构：**

   ```java
   import java.util.ArrayList;
   import java.util.Arrays;
   import java.util.List;
   
   public class PrimeNumbers {
   
       // 判断一个正整数 n 是否是质数
       public static boolean isPrime(int n) {
           if (n <= 1) {
               return false;
           }
           if (n <= 3) { // 2, 3 是质数
               return true;
           }
           if (n % 2 == 0 || n % 3 == 0) { // 排除 2 和 3 的倍数
               return false;
           }
           // 只需要检查到 sqrt(n)
           for (int i = 5; i * i <= n; i = i + 6) { // 优化：只检查 6k ± 1 形式的数
               if (n % i == 0 || n % (i + 2) == 0) {
                   return false;
               }
           }
           return true;
       }
   
       // 使用埃拉托斯特尼筛法找出小于等于 limit 的所有质数
       public static boolean[] sieveOfEratosthenes(int limit) {
           boolean[] isPrime = new boolean[limit + 1];
           Arrays.fill(isPrime, true); // 默认所有数都是质数
   
           if (limit >= 0) isPrime[0] = false; // 0 不是质数
           if (limit >= 1) isPrime[1] = false; // 1 不是质数
   
           // 从 2 开始，将质数的倍数标记为合数
           for (int p = 2; p * p <= limit; p++) {
               // 如果 isPrime[p] 仍然为 true，说明 p 是质数
               if (isPrime[p]) {
                   // 将 p 的所有倍数 (从 p*p 开始) 标记为 false
                   for (int i = p * p; i <= limit; i += p) {
                       isPrime[i] = false;
                   }
               }
           }
           return isPrime;
       }
   
       public static void main(String[] args) {
           int n1 = 17;
           System.out.println("Is " + n1 + " a prime number? " + isPrime(n1)); // Expected: true
   
           int n2 = 15;
           System.out.println("Is " + n2 + " a prime number? " + isPrime(n2)); // Expected: false
   
           int n3 = 2;
           System.out.println("Is " + n3 + " a prime number? " + isPrime(n3)); // Expected: true
   
           int limit = 30;
           boolean[] primes = sieveOfEratosthenes(limit);
           List<Integer> primeList = new ArrayList<>();
           for (int i = 0; i <= limit; i++) {
               if (primes[i]) {
                   primeList.add(i);
               }
           }
           System.out.println("\nPrimes up to " + limit + ": " + primeList); // Expected: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
   
           int limit2 = 2;
           boolean[] primes2 = sieveOfEratosthenes(limit2);
           List<Integer> primeList2 = new ArrayList<>();
           for (int i = 0; i <= limit2; i++) {
               if (primes2[i]) {
                   primeList2.add(i);
               }
           }
           System.out.println("Primes up to " + limit2 + ": " + primeList2); // Expected: [2]
       }
   }
   ```

2. **题目名称：** 计算最大公约数 (GCD) 和最小公倍数 (LCM) **题目描述：**

   - **部分 A：** 实现一个静态方法 `gcd(int a, int b)`，使用欧几里得算法计算两个非负整数 `a` 和 `b` 的最大公约数。
   - **部分 B：** 实现一个静态方法 `lcm(int a, int b)`，计算两个正整数 `a` 和 `b` 的最小公倍数。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   a = 48, b = 18
   a = 12, b = 18
   ```

   **输出示例：**

   ```
   GCD of 48 and 18: 6
   LCM of 12 and 18: 36
   ```

   **知识点描述：**

   - **欧几里得算法 (辗转相除法)：** `gcd(a, b) = gcd(b, a % b)`，直到 `b = 0`，此时 `a` 即为 GCD。
   - **LCM 与 GCD 的关系：** `lcm(a, b) = (a * b) / gcd(a, b)`。
   - **时间复杂度：** O(log(min(a,b)))。
   - **空间复杂度：** O(1) (迭代) 或 O(log(min(a,b))) (递归栈空间)。

   **参考代码结构：**

   ```java
   public class MathAlgorithms {
   
       // 使用欧几里得算法计算最大公约数 (GCD)
       // 迭代实现
       public static int gcd(int a, int b) {
           while (b != 0) {
               int temp = b;
               b = a % b;
               a = temp;
           }
           return a;
       }
   
       // 递归实现 (可选)
       public static int gcdRecursive(int a, int b) {
           if (b == 0) {
               return a;
           }
           return gcdRecursive(b, a % b);
       }
   
       // 计算最小公倍数 (LCM)
       public static int lcm(int a, int b) {
           if (a == 0 || b == 0) {
               return 0; // 0 的倍数只有 0
           }
           // LCM(a, b) = (a * b) / GCD(a, b)
           // 为了防止 a*b 溢出，可以先除后乘： (a / gcd(a, b)) * b
           return (a / gcd(a, b)) * b;
       }
   
       public static void main(String[] args) {
           int a1 = 48, b1 = 18;
           System.out.println("GCD of " + a1 + " and " + b1 + ": " + gcd(a1, b1)); // Expected: 6
   
           int a2 = 12, b2 = 18;
           System.out.println("LCM of " + a2 + " and " + b2 + ": " + lcm(a2, b2)); // Expected: 36
   
           int a3 = 7, b3 = 5; // 互质数
           System.out.println("\nGCD of " + a3 + " and " + b3 + ": " + gcd(a3, b3)); // Expected: 1
           System.out.println("LCM of " + a3 + " and " + b3 + ": " + lcm(a3, b3)); // Expected: 35
   
           int a4 = 0, b4 = 10;
           System.out.println("\nGCD of " + a4 + " and " + b4 + ": " + gcd(a4, b4)); // Expected: 10
           System.out.println("LCM of " + a4 + " and " + b4 + ": " + lcm(a4, b4)); // Expected: 0
       }
   }
   ```