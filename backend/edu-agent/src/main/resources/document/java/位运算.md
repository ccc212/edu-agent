## 45. 位运算 (Bit Manipulation)

### 45.1. 常见位操作 (Common Bit Operations)

- **知识点：** 位运算符 (`&`, `|`, `^`, `~`, `<<`, `>>`, `>>>`)；判断奇偶；判断某位是否为 1；设置/清除/翻转某位。

1. **题目名称：** 常见位操作实现 **题目描述：** 实现以下位操作的静态方法：

   - `isEven(int n)`：判断一个整数是否为偶数。
   - `getBit(int n, int k)`：获取整数 `n` 的第 `k` 位（从右往左，0-indexed）。
   - `setBit(int n, int k)`：将整数 `n` 的第 `k` 位设置为 1。
   - `clearBit(int n, int k)`：将整数 `n` 的第 `k` 位设置为 0。
   - `toggleBit(int n, int k)`：翻转整数 `n` 的第 `k` 位（0 变 1，1 变 0）。
   - 在 `main` 方法中，用多个示例测试你的实现，并打印结果的二进制表示（使用 `Integer.toBinaryString()`）。 **输入示例：**

   ```
   n = 10 (二进制 1010), k = 1 (第二位)
   ```

   **输出示例：**

   ```
   Is 10 even? true
   Bit at position 1 of 10 (1010): 1
   Set bit 0 of 10 (1010) to 1: 1011 (11)
   Clear bit 1 of 10 (1010) to 0: 1000 (8)
   Toggle bit 2 of 10 (1010) to 0: 0010 (2)
   ```

   **知识点描述：**

   - **`&` (按位与):** 用于检查位或清除位。
   - **`|` (按位或):** 用于设置位。
   - **`^` (按位异或):** 用于翻转位。
   - **`~` (按位非):** 对所有位取反。
   - **`<<` (左移):** `n << k` 将 `n` 的位向左移动 `k` 位，低位补 0，相当于 `n * 2^k`。
   - **`>>` (有符号右移):** `n >> k` 将 `n` 的位向右移动 `k` 位，高位补符号位，相当于 `n / 2^k`。
   - **`>>>` (无符号右移):** `n >>> k` 将 `n` 的位向右移动 `k` 位，高位补 0。
   - **时间复杂度：** O(1) (所有位操作)。
   - **空间复杂度：** O(1)。

   **参考代码结构：**

   ```java
   public class BitManipulation {
   
       // 判断一个整数是否为偶数
       public static boolean isEven(int n) {
           return (n & 1) == 0;
       }
   
       // 获取整数 n 的第 k 位 (从右往左，0-indexed)
       public static int getBit(int n, int k) {
           return (n >> k) & 1;
       }
   
       // 将整数 n 的第 k 位设置为 1
       public static int setBit(int n, int k) {
           return n | (1 << k);
       }
   
       // 将整数 n 的第 k 位设置为 0
       public static int clearBit(int n, int k) {
           return n & (~(1 << k));
       }
   
       // 翻转整数 n 的第 k 位 (0 变 1，1 变 0)
       public static int toggleBit(int n, int k) {
           return n ^ (1 << k);
       }
   
       public static void main(String[] args) {
           int n = 10; // 二进制: 1010
   
           System.out.println("Original number: " + n + " (Binary: " + Integer.toBinaryString(n) + ")");
   
           System.out.println("Is " + n + " even? " + isEven(n)); // Expected: true (1010 & 0001 == 0000)
   
           // k=0 (最右边位), k=1 (第二位), k=2 (第三位), k=3 (第四位)
           int k1 = 1;
           System.out.println("Bit at position " + k1 + " of " + n + " (" + Integer.toBinaryString(n) + "): " + getBit(n, k1)); // Expected: 1
   
           int k2 = 0;
           int nSet = setBit(n, k2);
           System.out.println("Set bit " + k2 + " of " + n + " (" + Integer.toBinaryString(n) + ") to 1: " + nSet + " (Binary: " + Integer.toBinaryString(nSet) + ")"); // Expected: 1011 (11)
   
           int k3 = 1;
           int nClear = clearBit(n, k3);
           System.out.println("Clear bit " + k3 + " of " + n + " (" + Integer.toBinaryString(n) + ") to 0: " + nClear + " (Binary: " + Integer.toBinaryString(nClear) + ")"); // Expected: 1000 (8)
   
           int k4 = 2;
           int nToggle = toggleBit(n, k4);
           System.out.println("Toggle bit " + k4 + " of " + n + " (" + Integer.toBinaryString(n) + ") to 0: " + nToggle + " (Binary: " + Integer.toBinaryString(nToggle) + ")"); // Expected: 0010 (2)
   
           int n5 = 7; // 二进制: 0111
           System.out.println("\nOriginal number: " + n5 + " (Binary: " + Integer.toBinaryString(n5) + ")");
           System.out.println("Is " + n5 + " even? " + isEven(n5)); // Expected: false
           System.out.println("Set bit 3 of " + n5 + " (" + Integer.toBinaryString(n5) + ") to 1: " + setBit(n5, 3) + " (Binary: " + Integer.toBinaryString(setBit(n5, 3)) + ")"); // Expected: 1111 (15)
       }
   }
   ```

### 45.2. 位运算技巧 (Bit Manipulation Tricks)

- **知识点：** 计算数字中 1 的个数 (Hamming Weight)；判断是否是 2 的幂；交换两个数字（不使用额外变量）。

1. **题目名称：** 实现位运算技巧 **题目描述：** 实现以下位运算技巧的静态方法：

   - `countSetBits(int n)`：计算一个非负整数 `n` 的二进制表示中 1 的个数（汉明权重）。
   - `isPowerOfTwo(int n)`：判断一个正整数 `n` 是否是 2 的幂。
   - `swapNumbers(int a, int b)`：交换两个整数 `a` 和 `b` 的值，不允许使用额外的临时变量。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   n = 13 (二进制 1101)
   n = 8
   a = 5, b = 10
   ```

   **输出示例：**

   ```
   Number of set bits in 13 (1101): 3
   Is 8 a power of two? true
   Is 12 a power of two? false
   Before swap: a = 5, b = 10
   After swap: a = 10, b = 5
   ```

   **知识点描述：**

   - **计算 1 的个数：** Brian Kernighan 算法 (`n & (n-1)`)。每次操作会清除 `n` 最右边的 1。
   - **判断 2 的幂：** 对于一个正整数 `n`，如果它是 2 的幂，那么它的二进制表示中只有一位是 1。因此，`n > 0` 且 `(n & (n-1)) == 0`。
   - **交换数字：** 使用异或运算的性质：`A ^ B ^ B = A`。
   - **时间复杂度：** O(logn) 或 O(number of set bits) (计数 1 的个数)，O(1) (判断 2 的幂、交换)。
   - **空间复杂度：** O(1)。

   **参考代码结构：**

   ```java
   public class BitManipulationTricks {
   
       // 计算一个非负整数 n 的二进制表示中 1 的个数 (汉明权重)
       // Brian Kernighan 算法
       public static int countSetBits(int n) {
           int count = 0;
           while (n > 0) {
               n &= (n - 1); // 每次操作清除 n 最右边的 1
               count++;
           }
           return count;
       }
   
       // 判断一个正整数 n 是否是 2 的幂
       public static boolean isPowerOfTwo(int n) {
           // 一个正整数是2的幂，当且仅当其二进制表示中只有一位是1
           // 例如 8 (1000), 8-1=7 (0111) => 8 & 7 = 0
           // 6 (0110), 6-1=5 (0101) => 6 & 5 = 4 (非0)
           return n > 0 && (n & (n - 1)) == 0;
       }
   
       // 交换两个整数 a 和 b 的值，不允许使用额外的临时变量
       // 使用异或运算的性质: A ^ B ^ B = A
       public static void swapNumbers(int[] arr) { // 传入数组，方便在main中展示改变
           // arr[0] = a, arr[1] = b
           System.out.println("Before swap: a = " + arr[0] + ", b = " + arr[1]);
           arr[0] = arr[0] ^ arr[1]; // a = a ^ b
           arr[1] = arr[0] ^ arr[1]; // b = (a ^ b) ^ b = a
           arr[0] = arr[0] ^ arr[1]; // a = (a ^ b) ^ a = b
           System.out.println("After swap: a = " + arr[0] + ", b = " + arr[1]);
       }
   
       public static void main(String[] args) {
           int n1 = 13; // Binary: 1101
           System.out.println("Number of set bits in " + n1 + " (" + Integer.toBinaryString(n1) + "): " + countSetBits(n1)); // Expected: 3
   
           int n2 = 7; // Binary: 0111
           System.out.println("Number of set bits in " + n2 + " (" + Integer.toBinaryString(n2) + "): " + countSetBits(n2)); // Expected: 3
   
           System.out.println("\nIs 8 a power of two? " + isPowerOfTwo(8));   // Expected: true
           System.out.println("Is 12 a power of two? " + isPowerOfTwo(12)); // Expected: false
           System.out.println("Is 1 a power of two? " + isPowerOfTwo(1));   // Expected: true
           System.out.println("Is 0 a power of two? " + isPowerOfTwo(0));   // Expected: false
   
           int[] numsToSwap = {5, 10};
           swapNumbers(numsToSwap); // Pass an array to allow modification of values in main
           // For primitive types directly:
           // int a = 5, b = 10;
           // a = a ^ b; b = a ^ b; a = a ^ b;
           // System.out.println("a = " + a + ", b = " + b);
       }
   }
   ```
