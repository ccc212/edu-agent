## 43. 回溯算法 (Backtracking)

### 43.1. 组合与排列 (Combinations & Permutations)

- **知识点：** 回溯算法的基本框架；剪枝 (Pruning)；状态的保存与恢复；递归。

1. **题目名称：** 组合总和 (Combination Sum) **题目描述：** 给定一个 **无重复元素** 的整数数组 `candidates` 和一个目标和 `target`，找出 `candidates` 中所有可以使数字和为 `target` 的组合。`candidates` 中的每个数字可以重复使用多次。

   - 实现一个静态方法 `combinationSum(int[] candidates, int target)`，返回所有符合条件的组合列表。
   - 在 `main` 方法中，用一个示例测试你的实现。 **输入示例：**

   ```
   candidates = {2, 3, 6, 7}, target = 7
   ```

   **输出示例：**

   ```
   Combinations for target 7:
   [2, 2, 3]
   [7]
   ```

   **知识点描述：**

   - 回溯框架：
     1. **选择：** 在当前路径上尝试一个可能的选择。
     2. **探索：** 递归地探索下一个状态。
     3. **撤销选择：** 回到上一个状态，为下一次选择做准备（清理当前选择对状态的影响）。
   - **剪枝：** 当当前和超过 `target` 时，停止进一步探索。由于数字可以重复使用，且无序，通常会对 `candidates` 数组进行排序，以避免重复解（虽然此题本身因为数字可重复不涉及，但在求不重复组合时排序很重要）和方便剪枝。
   - **时间复杂度：** 难以精确计算，通常是指数级的。
   - **空间复杂度：** O(target⋅N) (取决于递归深度和结果列表大小)。

   **参考代码结构：**

   

   ```java
   import java.util.ArrayList;
   import java.util.Arrays;
   import java.util.List;
   
   public class CombinationSum {
   
       public static List<List<Integer>> combinationSum(int[] candidates, int target) {
           List<List<Integer>> result = new ArrayList<>();
           // 对 candidates 排序，有助于剪枝优化和避免重复 (如果数字不重复使用且需要去重)
           // 对于本题 (数字可重复使用)，排序主要为了剪枝
           Arrays.sort(candidates);
           backtrack(candidates, target, 0, new ArrayList<>(), result);
           return result;
       }
   
       private static void backtrack(int[] candidates, int target, int startIdx,
                                     List<Integer> currentCombination, List<List<Integer>> result) {
           // 终止条件
           if (target == 0) {
               result.add(new ArrayList<>(currentCombination)); // 找到一个有效组合，添加到结果
               return;
           }
           if (target < 0) {
               return; // 和已经超过目标，剪枝
           }
   
           // 遍历选择列表
           for (int i = startIdx; i < candidates.length; i++) {
               int candidate = candidates[i];
               // 剪枝优化：如果当前候选数已经大于剩余目标，则后续更大的数也不可能满足
               if (candidate > target) {
                   break;
               }
   
               // 做出选择
               currentCombination.add(candidate);
   
               // 递归探索 (注意：可以重复使用当前数字，所以下一轮从当前索引 i 开始)
               backtrack(candidates, target - candidate, i, currentCombination, result);
   
               // 撤销选择 (回溯)
               currentCombination.remove(currentCombination.size() - 1);
           }
       }
   
       public static void main(String[] args) {
           int[] candidates1 = {2, 3, 6, 7};
           int target1 = 7;
           List<List<Integer>> combinations1 = combinationSum(candidates1, target1);
           System.out.println("Combinations for target " + target1 + ":");
           for (List<Integer> combo : combinations1) {
               System.out.println(combo);
           }
           // Expected:
           // [2, 2, 3]
           // [7]
   
           int[] candidates2 = {2, 3, 5};
           int target2 = 8;
           List<List<Integer>> combinations2 = combinationSum(candidates2, target2);
           System.out.println("\nCombinations for target " + target2 + ":");
           for (List<Integer> combo : combinations2) {
               System.out.println(combo);
           }
           // Expected:
           // [2, 2, 2, 2]
           // [2, 3, 3]
           // [3, 5]
       }
   }
   ```

2. **题目名称：** 全排列 (Permutations) **题目描述：** 给定一个 **没有重复数字** 的序列，返回其所有可能的全排列。

   - 实现一个静态方法 `permute(int[] nums)`，返回所有可能的全排列列表。
   - 在 `main` 方法中，用一个示例测试你的实现。 **输入示例：** `nums = {1, 2, 3}` **输出示例：**

   ```
   Permutations for [1, 2, 3]:
   [1, 2, 3]
   [1, 3, 2]
   [2, 1, 3]
   [2, 3, 1]
   [3, 1, 2]
   [3, 2, 1]
   ```

   **知识点描述：**

   - **回溯框架：** 类似组合问题，但在每次选择时，需要避免重复使用已选择的元素。通常使用一个 `boolean[] used` 数组来标记哪些元素已被使用。
   - **剪枝：** 当当前排列的长度等于原数组长度时，即找到一个完整的排列。
   - **时间复杂度：** O(N⋅N!) (N! 种排列，每种排列需要 O(N) 时间构建)。
   - **空间复杂度：** O(N) (递归栈深度和当前排列列表)。

   **参考代码结构：**

   ```java
   import java.util.ArrayList;
   import java.util.List;
   import java.util.Arrays;
   
   public class Permutations {
   
       public static List<List<Integer>> permute(int[] nums) {
           List<List<Integer>> result = new ArrayList<>();
           // used 数组用于标记哪些数字已经被使用过
           boolean[] used = new boolean[nums.length];
           backtrack(nums, used, new ArrayList<>(), result);
           return result;
       }
   
       private static void backtrack(int[] nums, boolean[] used,
                                     List<Integer> currentPermutation, List<List<Integer>> result) {
           // 终止条件：当当前排列的长度等于原数组长度时，说明找到一个完整排列
           if (currentPermutation.size() == nums.length) {
               result.add(new ArrayList<>(currentPermutation));
               return;
           }
   
           // 遍历所有可能的选择
           for (int i = 0; i < nums.length; i++) {
               if (used[i]) {
                   continue; // 如果当前数字已经被使用过，则跳过
               }
   
               // 做出选择
               currentPermutation.add(nums[i]);
               used[i] = true; // 标记为已使用
   
               // 递归探索
               backtrack(nums, used, currentPermutation, result);
   
               // 撤销选择 (回溯)
               used[i] = false; // 解除标记
               currentPermutation.remove(currentPermutation.size() - 1);
           }
       }
   
       public static void main(String[] args) {
           int[] nums1 = {1, 2, 3};
           List<List<Integer>> permutations1 = permute(nums1);
           System.out.println("Permutations for " + Arrays.toString(nums1) + ":");
           for (List<Integer> p : permutations1) {
               System.out.println(p);
           }
   
           int[] nums2 = {0, 1};
           List<List<Integer>> permutations2 = permute(nums2);
           System.out.println("\nPermutations for " + Arrays.toString(nums2) + ":");
           for (List<Integer> p : permutations2) {
               System.out.println(p);
           }
       }
   }
   ```