## 50. 高级数据结构及其应用 (Advanced Data Structures and Their Applications)

### 50.1. Trie (前缀树 / 字典树)

- **知识点：** 树形结构；节点定义；插入、查找、前缀查找操作。

1. **题目名称：** 实现 Trie (前缀树) **题目描述：** 实现一个 Trie (前缀树) 数据结构，支持以下操作：

   - `insert(String word)`：向 Trie 中插入一个单词。
   - `search(String word)`：如果单词在 Trie 中，返回 `true`；否则，返回 `false`。
   - `startsWith(String prefix)`：如果 Trie 中有任何一个单词以 `prefix` 作为前缀，返回 `true`；否则，返回 `false`。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   insert("apple")
   search("apple")
   search("app")
   startsWith("app")
   insert("app")
   search("app")
   ```

   **输出示例：**

   ```
   Search "apple": true
   Search "app": false
   Starts with "app": true
   Search "app": true
   ```

   **知识点描述：**

   - **节点结构：** 每个 Trie 节点通常包含一个指向子节点的数组（或 Map，用于节省空间）以及一个布尔标记，表示该节点是否是某个单词的结尾。
   - **插入：** 遍历单词的每个字符，如果当前字符对应的子节点不存在，则创建新节点，并移动到该子节点。到达单词末尾时，标记当前节点为单词结尾。
   - **查找：** 遍历单词的每个字符，沿着对应的子节点向下。如果在任何一步，子节点不存在或未到达单词结尾，则查找失败。
   - **前缀查找：** 类似查找，但不要求到达字符串末尾的节点必须是单词结尾。
   - **时间复杂度：** O(L) (L 是字符串长度)，对于所有操作。
   - **空间复杂度：** O(N⋅L⋅Σ) (N 是单词数量，L 是平均单词长度，Σ 是字符集大小)，取决于存储的单词数量和单词长度。

   **参考代码结构：**

   ```java
   import java.util.HashMap;
   import java.util.Map;
   
   // Trie 节点类
   class TrieNode {
       Map<Character, TrieNode> children;
       boolean isEndOfWord; // 标记是否是一个单词的结束
   
       public TrieNode() {
           children = new HashMap<>(); // 或者 new TrieNode[26] 如果只考虑小写英文字母
           isEndOfWord = false;
       }
   }
   
   public class Trie {
       private TrieNode root;
   
       public Trie() {
           root = new TrieNode();
       }
   
       // 插入一个单词
       public void insert(String word) {
           TrieNode current = root;
           for (char ch : word.toCharArray()) {
               // 如果子节点不存在，则创建
               current.children.putIfAbsent(ch, new TrieNode());
               current = current.children.get(ch);
           }
           current.isEndOfWord = true; // 标记单词结尾
           System.out.println("Inserted: \"" + word + "\"");
       }
   
       // 查找一个单词
       public boolean search(String word) {
           TrieNode current = root;
           for (char ch : word.toCharArray()) {
               current = current.children.get(ch);
               if (current == null) {
                   return false; // 路径不存在
               }
           }
           return current.isEndOfWord; // 必须是单词的结尾
       }
   
       // 判断是否有单词以给定前缀开始
       public boolean startsWith(String prefix) {
           TrieNode current = root;
           for (char ch : prefix.toCharArray()) {
               current = current.children.get(ch);
               if (current == null) {
                   return false; // 路径不存在
               }
           }
           return true; // 找到了前缀对应的路径
       }
   
       public static void main(String[] args) {
           Trie trie = new Trie();
           trie.insert("apple");
           System.out.println("Search \"apple\": " + trie.search("apple"));   // true
           System.out.println("Search \"app\": " + trie.search("app"));       // false
           System.out.println("Starts with \"app\": " + trie.startsWith("app")); // true
           trie.insert("app");
           System.out.println("Search \"app\": " + trie.search("app"));       // true
           System.out.println("Search \"ap\": " + trie.search("ap"));         // false
           System.out.println("Starts with \"ap\": " + trie.startsWith("ap")); // true
       }
   }
   ```

### 50.2. Segment Tree (线段树)

- **知识点：** 树形结构；区间查询；单点更新或区间更新。

1. **题目名称：** 实现 Segment Tree (区间和查询) **题目描述：** 实现一个支持以下操作的线段树：

   - `build(int[] nums)`：从给定的数组 `nums` 构建线段树。
   - `update(int index, int val)`：将数组中 `index` 位置的值更新为 `val`。
   - `query(int left, int right)`：查询数组中 `left` 到 `right` 区间（包含）的和。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   nums = {1, 3, 5, 7, 9, 11}
   query(0, 5) // 查询所有元素的和
   update(1, 2) // 将索引1的值从3更新为2
   query(0, 2) // 查询索引0到2的和
   ```

   **输出示例：**

   ```
   Initial array: [1, 3, 5, 7, 9, 11]
   Sum of range [0, 5]: 36
   Updated array: [1, 2, 5, 7, 9, 11]
   Sum of range [0, 2] after update: 8
   ```

   **知识点描述：**

   - **结构：** 线段树是一种二叉树，每个节点代表一个区间。根节点代表整个数组的区间，左右子节点分别代表左右两个子区间。叶子节点代表数组的单个元素。
   - **构建：** 递归地将区间划分为两半，直到叶子节点。非叶子节点存储其子节点代表区间的聚合结果（例如和、最大值、最小值等）。
   - **更新：** 从根节点开始，根据更新的索引向下遍历到对应的叶子节点，更新其值，然后回溯，逐层更新父节点的值。
   - **查询：** 从根节点开始，根据查询区间与当前节点区间的关系进行递归。如果当前节点区间完全包含在查询区间内，直接返回节点值；如果完全不相交，返回默认值；否则，递归查询左右子节点，并合并结果。
   - 时间复杂度：
     - 构建：O(N)。
     - 更新：O(logN)。
     - 查询：O(logN)。
   - **空间复杂度：** O(N) (线段树通常是原数组大小的 2 到 4 倍)。
   - **适用场景：** 对区间进行频繁的查询和单点/区间更新操作。

   **参考代码结构：**

   ```java
   import java.util.Arrays;
   
   public class SegmentTree {
       private int[] tree; // 存储线段树的数组
       private int[] nums; // 原始数组
       private int N;      // 原始数组的大小
   
       // 构造器
       public SegmentTree(int[] nums) {
           this.nums = nums;
           this.N = nums.length;
           // 线段树数组大小通常是 4 * N，以确保足够空间
           this.tree = new int[4 * N];
           if (N > 0) {
               build(0, 0, N - 1); // 从根节点开始构建
           }
       }
   
       /**
        * 构建线段树
        * @param node 当前树节点的索引
        * @param start 当前节点代表区间的起始索引
        * @param end 当前节点代表区间的结束索引
        */
       private void build(int node, int start, int end) {
           if (start == end) { // 叶子节点
               tree[node] = nums[start];
           } else {
               int mid = (start + end) / 2;
               build(2 * node + 1, start, mid);       // 构建左子树
               build(2 * node + 2, mid + 1, end);     // 构建右子树
               tree[node] = tree[2 * node + 1] + tree[2 * node + 2]; // 合并子节点的结果
           }
       }
   
       /**
        * 更新数组中某个位置的值
        * @param index 要更新的数组索引
        * @param val 新值
        */
       public void update(int index, int val) {
           update(0, 0, N - 1, index, val);
           this.nums[index] = val; // 更新原始数组
           System.out.println("Updated index " + index + " to " + val + ". Array: " + Arrays.toString(this.nums));
       }
   
       /**
        * 实际的更新递归方法
        * @param node 当前树节点的索引
        * @param start 当前节点代表区间的起始索引
        * @param end 当前节点代表区间的结束索引
        * @param idx 要更新的数组索引
        * @param val 新值
        */
       private void update(int node, int start, int end, int idx, int val) {
           if (start == end) { // 找到叶子节点
               tree[node] = val;
           } else {
               int mid = (start + end) / 2;
               if (start <= idx && idx <= mid) { // 索引在左子区间
                   update(2 * node + 1, start, mid, idx, val);
               } else { // 索引在右子区间
                   update(2 * node + 2, mid + 1, end, idx, val);
               }
               tree[node] = tree[2 * node + 1] + tree[2 * node + 2]; // 重新计算父节点的值
           }
       }
   
       /**
        * 查询指定区间的和
        * @param queryLeft 查询区间的起始索引
        * @param queryRight 查询区间的结束索引
        * @return 区间和
        */
       public int query(int queryLeft, int queryRight) {
           return query(0, 0, N - 1, queryLeft, queryRight);
       }
   
       /**
        * 实际的查询递归方法
        * @param node 当前树节点的索引
        * @param start 当前节点代表区间的起始索引
        * @param end 当前节点代表区间的结束索引
        * @param queryLeft 查询区间的起始索引
        * @param queryRight 查询区间的结束索引
        * @return 区间和
        */
       private int query(int node, int start, int end, int queryLeft, int queryRight) {
           // 情况 1: 当前节点区间完全包含在查询区间内
           if (queryLeft <= start && end <= queryRight) {
               return tree[node];
           }
           // 情况 2: 当前节点区间与查询区间完全不相交
           if (end < queryLeft || start > queryRight) {
               return 0; // 返回聚合操作的“零元素” (和操作的零元素是 0)
           }
   
           // 情况 3: 当前节点区间与查询区间部分重叠，需要递归查询子区间
           int mid = (start + end) / 2;
           int p1 = query(2 * node + 1, start, mid, queryLeft, queryRight);
           int p2 = query(2 * node + 2, mid + 1, end, queryLeft, queryRight);
           return p1 + p2;
       }
   
       public static void main(String[] args) {
           int[] nums = {1, 3, 5, 7, 9, 11};
           System.out.println("Initial array: " + Arrays.toString(nums));
           SegmentTree segmentTree = new SegmentTree(nums);
   
           System.out.println("Sum of range [0, 5]: " + segmentTree.query(0, 5)); // Expected: 36 (1+3+5+7+9+11)
           System.out.println("Sum of range [2, 4]: " + segmentTree.query(2, 4)); // Expected: 21 (5+7+9)
   
           segmentTree.update(1, 2); // 将索引1的值从3更新为2
           System.out.println("Sum of range [0, 2] after update: " + segmentTree.query(0, 2)); // Expected: 1+2+5 = 8
           System.out.println("Sum of range [0, 5] after update: " + segmentTree.query(0, 5)); // Expected: 1+2+5+7+9+11 = 35
   
           int[] nums2 = {10, 20, 30};
           SegmentTree segmentTree2 = new SegmentTree(nums2);
           System.out.println("\nInitial array 2: " + Arrays.toString(nums2));
           System.out.println("Sum of range [0, 2]: " + segmentTree2.query(0, 2)); // Expected: 60
           segmentTree2.update(0, 5);
           System.out.println("Sum of range [0, 2] after update: " + segmentTree2.query(0, 2)); // Expected: 55
       }
   }
   ```