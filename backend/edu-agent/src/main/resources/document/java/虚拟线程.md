## 31. 虚拟线程 (Virtual Threads) (Java 21+)

### 31.1. 虚拟线程的创建与使用 (Virtual Thread Creation & Usage)

- **知识点：** 虚拟线程 (Project Loom) 的引入与目的（轻量级、高吞吐量并发，解决传统线程上下文切换开销大问题）；平台线程 (Platform Thread) 与虚拟线程的区别；`Thread.ofVirtual()`；`Executors.newVirtualThreadPerTaskExecutor()`。
- **注意：** 虚拟线程是 Java 21 及更高版本中的特性。

1. 题目名称：

    模拟大量并发请求（虚拟线程 vs 平台线程）

   题目描述：

   - 编写一个模拟任务，该任务打印当前线程名，然后睡眠一小段时间（例如 100 毫秒），再打印一次。
   - **部分 A (平台线程):** 创建一个固定大小的平台线程池 (例如 10 个线程)，向其中提交 1000 个上述模拟任务，记录总耗时。
   - **部分 B (虚拟线程):** 创建一个虚拟线程池（`newVirtualThreadPerTaskExecutor()`），向其中提交 1000 个相同的模拟任务，记录总耗时。
   - 比较两种情况下任务的启动速度和总耗时，体会虚拟线程在 I/O 密集型任务中的优势。 **参考代码结构：**

   ```java
   import java.time.Duration;
   import java.time.Instant;
   import java.util.concurrent.ExecutorService;
   import java.util.concurrent.Executors;
   import java.util.concurrent.TimeUnit;
   import java.util.stream.IntStream;
   
   public class VirtualThreadDemo {
   
       private static void runTasks(ExecutorService executor, int numTasks, String type) throws InterruptedException {
           Instant start = Instant.now();
           for (int i = 0; i < numTasks; i++) {
               final int taskId = i;
               executor.submit(() -> {
                   // System.out.println(type + " Thread " + Thread.currentThread().getName() + " starting task " + taskId);
                   try {
                       Thread.sleep(100); // 模拟I/O操作或短暂阻塞
                   } catch (InterruptedException e) {
                       Thread.currentThread().interrupt();
                   }
                   // System.out.println(type + " Thread " + Thread.currentThread().getName() + " finishing task " + taskId);
               });
           }
           executor.shutdown();
           executor.awaitTermination(1, TimeUnit.MINUTES);
           Instant end = Instant.now();
           System.out.println(type + " executed " + numTasks + " tasks in " + Duration.between(start, end).toMillis() + " ms");
       }
   
       public static void main(String[] args) throws InterruptedException {
           int numberOfTasks = 1000;
   
           System.out.println("--- Running with Platform Threads ---");
           // 固定大小的平台线程池
           ExecutorService platformExecutor = Executors.newFixedThreadPool(10); // 限制同时运行的线程数量
           runTasks(platformExecutor, numberOfTasks, "Platform");
   
           System.out.println("\n--- Running with Virtual Threads ---");
           // 虚拟线程池
           ExecutorService virtualExecutor = Executors.newVirtualThreadPerTaskExecutor(); // 每个任务一个虚拟线程
           runTasks(virtualExecutor, numberOfTasks, "Virtual");
   
           // 直接创建并启动虚拟线程的例子 (可选)
           System.out.println("\n--- Direct Virtual Thread Creation ---");
           Instant startDirect = Instant.now();
           Thread.ofVirtual().start(() -> {
               System.out.println("Direct Virtual Thread: " + Thread.currentThread().getName());
               try {
                   Thread.sleep(50);
               } catch (InterruptedException e) {
                   Thread.currentThread().interrupt();
               }
           });
           Thread.ofPlatform().start(() -> {
               System.out.println("Direct Platform Thread: " + Thread.currentThread().getName());
           });
           // 确保这些线程有机会完成
           TimeUnit.MILLISECONDS.sleep(100);
           Instant endDirect = Instant.now();
           System.out.println("Direct threads started in " + Duration.between(startDirect, endDirect).toNanos() + " ns");
       }
   }
   ```
