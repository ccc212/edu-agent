## 48. 动态规划进阶 (Advanced Dynamic Programming)

### 48.1. 最长公共子序列 (Longest Common Subsequence, LCS)

- **知识点：** LCS 定义；动态规划状态转移方程；二维 DP 表。

1. **题目名称：** 最长公共子序列 **题目描述：** 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。一个子序列是字符串的派生序列，删除原始字符串中的一些（或不删除）字符而不改变剩余字符的相对顺序。

   - 实现一个静态方法 `longestCommonSubsequence(String text1, String text2)`。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   text1 = "abcde", text2 = "ace"
   ```

   **输出示例：**

   ```
   Length of LCS: 3 (Subsequence is "ace")
   ```

   **知识点描述：**

   - **状态定义：** `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。
   - 状态转移方程：
     - 如果 `text1.charAt(i-1) == text2.charAt(j-1)` (当前字符匹配)：`dp[i][j] = 1 + dp[i-1][j-1]`。
     - 如果 `text1.charAt(i-1) != text2.charAt(j-1)` (当前字符不匹配)：`dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])`。
   - **基础情况：** `dp[0][j] = 0` 和 `dp[i][0] = 0`。
   - **时间复杂度：** O(M⋅N) (M, N 分别是两个字符串的长度)。
   - **空间复杂度：** O(M⋅N)。

   **参考代码结构：**

   ```java
   public class LongestCommonSubsequence {
   
       public static int longestCommonSubsequence(String text1, String text2) {
           int m = text1.length();
           int n = text2.length();
   
           // dp[i][j] 存储 text1 的前 i 个字符 和 text2 的前 j 个字符的 LCS 长度
           int[][] dp = new int[m + 1][n + 1];
   
           // 填充 dp 表
           for (int i = 1; i <= m; i++) {
               for (int j = 1; j <= n; j++) {
                   // 如果当前字符匹配
                   if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                       dp[i][j] = 1 + dp[i - 1][j - 1];
                   } else { // 如果当前字符不匹配
                       dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                   }
               }
           }
           return dp[m][n]; // 返回整个字符串的 LCS 长度
       }
   
       public static void main(String[] args) {
           String text1_1 = "abcde";
           String text2_1 = "ace";
           System.out.println("LCS of \"" + text1_1 + "\" and \"" + text2_1 + "\": " +
                              longestCommonSubsequence(text1_1, text2_1)); // Expected: 3
   
           String text1_2 = "abc";
           String text2_2 = "abc";
           System.out.println("LCS of \"" + text1_2 + "\" and \"" + text2_2 + "\": " +
                              longestCommonSubsequence(text1_2, text2_2)); // Expected: 3
   
           String text1_3 = "abc";
           String text2_3 = "def";
           System.out.println("LCS of \"" + text1_3 + "\" and \"" + text2_3 + "\": " +
                              longestCommonSubsequence(text1_3, text2_3)); // Expected: 0
   
           String text1_4 = "AGGTAB";
           String text2_4 = "GXTXAYB";
           System.out.println("LCS of \"" + text1_4 + "\" and \"" + text2_4 + "\": " +
                              longestCommonSubsequence(text1_4, text2_4)); // Expected: 4 (GTAB)
       }
   }
   ```

### 48.2. 编辑距离 (Edit Distance / Levenshtein Distance)

- **知识点：** 编辑距离定义（插入、删除、替换操作）；动态规划状态转移方程；二维 DP 表。

1. **题目名称：** 编辑距离 **题目描述：** 给你两个单词 `word1` 和 `word2`，请你计算出将 `word1` 转换成 `word2` 所使用的最少操作数。你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。

   - 实现一个静态方法 `minDistance(String word1, String word2)`。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   word1 = "horse", word2 = "ros"
   ```

   **输出示例：**

   ```
   Minimum edit distance: 3
   (horse -> rorse (替换 h->r)
    rorse -> rose (删除 r)
    rose -> ros (删除 e)
   ```

   **知识点描述：**

   - **状态定义：** `dp[i][j]` 表示 `word1` 的前 `i` 个字符转换成 `word2` 的前 `j` 个字符所需的最少操作数。
   - 状态转移方程：
     - 如果 `word1.charAt(i-1) == word2.charAt(j-1)` (当前字符匹配)：`dp[i][j] = dp[i-1][j-1]` (无需操作)。
     - 如果 `word1.charAt(i-1) != word2.charAt(j-1)` (当前字符不匹配)： `dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])` (分别对应删除 `word1[i-1]`、插入 `word2[j-1]`、替换 `word1[i-1]` 为 `word2[j-1]`)。
   - 基础情况：
     - `dp[i][0] = i` (将 `word1` 的前 `i` 个字符转换为空字符串，需要 `i` 次删除)。
     - `dp[0][j] = j` (将空字符串转换成 `word2` 的前 `j` 个字符，需要 `j` 次插入)。
   - **时间复杂度：** O(M⋅N)。
   - **空间复杂度：** O(M⋅N)。

   **参考代码结构：**

   ```java
   public class EditDistance {
   
       public static int minDistance(String word1, String word2) {
           int m = word1.length();
           int n = word2.length();
   
           // dp[i][j] 表示 word1 的前 i 个字符 转换成 word2 的前 j 个字符所需的最少操作数
           int[][] dp = new int[m + 1][n + 1];
   
           // 初始化边界条件
           for (int i = 0; i <= m; i++) {
               dp[i][0] = i; // word1 的前 i 个字符转换成空字符串，需要 i 次删除
           }
           for (int j = 0; j <= n; j++) {
               dp[0][j] = j; // 空字符串转换成 word2 的前 j 个字符，需要 j 次插入
           }
   
           // 填充 dp 表
           for (int i = 1; i <= m; i++) {
               for (int j = 1; j <= n; j++) {
                   // 如果当前字符匹配
                   if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                       dp[i][j] = dp[i - 1][j - 1]; // 无需操作，直接取左上角值
                   } else { // 如果当前字符不匹配
                       // dp[i-1][j] + 1 : 删除 word1.charAt(i-1)
                       // dp[i][j-1] + 1 : 插入 word2.charAt(j-1)
                       // dp[i-1][j-1] + 1 : 替换 word1.charAt(i-1) 为 word2.charAt(j-1)
                       dp[i][j] = 1 + Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1]));
                   }
               }
           }
           return dp[m][n];
       }
   
       public static void main(String[] args) {
           String word1_1 = "horse";
           String word2_1 = "ros";
           System.out.println("Min distance between \"" + word1_1 + "\" and \"" + word2_1 + "\": " +
                              minDistance(word1_1, word2_1)); // Expected: 3
   
           String word1_2 = "intention";
           String word2_2 = "execution";
           System.out.println("Min distance between \"" + word1_2 + "\" and \"" + word2_2 + "\": " +
                              minDistance(word1_2, word2_2)); // Expected: 5
   
           String word1_3 = "kitten";
           String word2_3 = "sitting";
           System.out.println("Min distance between \"" + word1_3 + "\" and \"" + word2_3 + "\": " +
                              minDistance(word1_3, word2_3)); // Expected: 3
       }
   }
   ```

### 48.3. 硬币找零问题 (Coin Change Problem)

- **知识点：** 组合问题或最少硬币数问题；动态规划。

1. **题目名称：** 硬币找零 (最少硬币数) **题目描述：** 给定不同面额的硬币 `coins` 和一个总金额 `amount`。编写一个函数来计算可以凑成总金额所需的最少硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。假设每种硬币的数量是无限的。

   - 实现一个静态方法 `coinChange(int[] coins, int amount)`。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   coins = {1, 2, 5}, amount = 11
   ```

   **输出示例：**

   ```
   Minimum coins for amount 11: 3 (5 + 5 + 1)
   ```

   **知识点描述：**

   - **状态定义：** `dp[i]` 表示凑成金额 `i` 所需的最少硬币数。
   - **状态转移方程：** `dp[i] = min(dp[i], dp[i - coin] + 1)`，其中 `coin` 是所有可能的硬币面额。
   - **基础情况：** `dp[0] = 0` (凑成金额 0 需要 0 个硬币)。
   - **初始化：** 将所有 `dp[i]` 初始化为 `amount + 1` (一个比任何有效解都大的值，表示不可达)。
   - **时间复杂度：** O(amount⋅coins.length)。
   - **空间复杂度：** O(amount)。

   **参考代码结构：**

   ```java
   import java.util.Arrays;
   
   public class CoinChangeProblem {
   
       public static int coinChange(int[] coins, int amount) {
           // dp[i] 表示凑成金额 i 所需的最少硬币数
           // 初始化 dp 数组，将所有值设置为 amount + 1 (一个比任何有效解都大的值)
           int[] dp = new int[amount + 1];
           Arrays.fill(dp, amount + 1);
   
           // 基础情况：凑成金额 0 需要 0 个硬币
           dp[0] = 0;
   
           // 遍历所有金额
           for (int i = 1; i <= amount; i++) {
               // 遍历所有硬币面额
               for (int coin : coins) {
                   // 如果当前金额 i 大于或等于硬币面额 coin
                   // 并且 dp[i - coin] 是可达的 (不是 amount + 1)
                   if (i >= coin && dp[i - coin] != amount + 1) {
                       // 更新 dp[i] 为当前值和 (dp[i - coin] + 1) 中的最小值
                       dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                   }
               }
           }
   
           // 如果 dp[amount] 仍然是 amount + 1，表示无法凑成该金额
           return (dp[amount] == amount + 1) ? -1 : dp[amount];
       }
   
       public static void main(String[] args) {
           int[] coins1 = {1, 2, 5};
           int amount1 = 11;
           System.out.println("Minimum coins for amount " + amount1 + ": " +
                              coinChange(coins1, amount1)); // Expected: 3 (5+5+1)
   
           int[] coins2 = {2};
           int amount2 = 3;
           System.out.println("Minimum coins for amount " + amount2 + ": " +
                              coinChange(coins2, amount2)); // Expected: -1
   
           int[] coins3 = {1};
           int amount3 = 0;
           System.out.println("Minimum coins for amount " + amount3 + ": " +
                              coinChange(coins3, amount3)); // Expected: 0
   
           int[] coins4 = {186, 419, 83, 408};
           int amount4 = 6249;
           System.out.println("Minimum coins for amount " + amount4 + ": " +
                              coinChange(coins4, amount4)); // Expected: 20
       }
   }
   ```