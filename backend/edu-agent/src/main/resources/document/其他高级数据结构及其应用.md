## 51. 其他高级数据结构及其应用 (Other Advanced Data Structures and Their Applications)

### 51.1. Fenwick Tree (Binary Indexed Tree / BIT)

- **知识点：** 树状数组结构；前缀和查询；单点更新；低位运算 (`x & -x`)。

1. **题目名称：** 实现 Fenwick Tree (树状数组) **题目描述：** 实现一个 Fenwick Tree (也称作 Binary Indexed Tree, BIT) 数据结构，支持以下操作：

   - `build(int[] nums)`：从给定的数组 `nums` 构建树状数组。
   - `update(int index, int val)`：将数组中 `index` 位置的值增加 `val`。
   - `prefixSum(int index)`：查询从索引 0 到 `index`（包含）的前缀和。
   - `rangeSum(int left, int right)`：查询数组中 `left` 到 `right` 区间（包含）的和。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   nums = {1, 2, 3, 4, 5, 6, 7, 8}
   prefixSum(3) // 查询索引 0 到 3 的和
   update(2, 5) // 将索引 2 的值增加 5
   rangeSum(1, 4) // 查询索引 1 到 4 的和
   ```

   **输出示例：**

   ```
   Initial array: [1, 2, 3, 4, 5, 6, 7, 8]
   Prefix sum up to index 3: 10 (1+2+3+4)
   Updated array (conceptually): [1, 2, 8, 4, 5, 6, 7, 8]
   Range sum from index 1 to 4 after update: 19 (2+8+4+5)
   ```

   **知识点描述：**

   - **结构：** 树状数组是一个能够高效计算和更新元素前缀和的数据结构。它是一个数组，每个元素存储一个特定区间的和，通过位运算 `x & -x` 来快速定位和更新父节点/子节点。
   - **`x & -x` (lowbit)：** 这个操作用于获取 `x` 的二进制表示中最低位的 1 及其后面的所有 0 组成的数。例如，`12 (1100)` 的 `lowbit` 是 `4 (0100)`。它表示了当前节点负责的区间长度。
   - **更新 (`update`)：** 当更新 `index` 处的值时，需要将 `index` 及其所有父节点的值都进行更新。每次 `index += (index & -index)` 会跳到下一个需要更新的父节点。
   - **前缀和查询 (`prefixSum`)：** 从 `index` 开始，每次 `index -= (index & -index)` 会跳到下一个需要累加的“前缀区间”的结束位置，直到 `index` 变为 0。
   - **区间和查询 (`rangeSum`)：** `rangeSum(left, right) = prefixSum(right) - prefixSum(left - 1)`。
   - 时间复杂度：
     - 构建：`O(N log N)` (通过 N 次单点更新)。如果直接在原数组上构建，也可以是 `O(N)`。
     - 更新：`O(log N)`。
     - 查询：`O(log N)`。
   - **空间复杂度：** `O(N)`。
   - **适用场景：** 对数组进行频繁的单点更新和区间和查询（或其他可合并的区间操作）。与线段树相比，实现更简洁，但功能通常不如线段树灵活（例如，不能直接支持区间更新）。

   **参考代码结构：**

   ```java
   import java.util.Arrays;
   
   public class FenwickTree {
       private int[] bit; // Fenwick Tree (树状数组)
       private int N;     // 原始数组的大小
   
       // 构造器
       // 这里的 build 是通过多次 update 实现的，所以复杂度为 O(N log N)
       public FenwickTree(int[] nums) {
           this.N = nums.length;
           this.bit = new int[N + 1]; // BIT 数组通常从索引 1 开始
   
           // 从原始数组构建 BIT
           for (int i = 0; i < N; i++) {
               // 注意：这里是对 nums[i] 的值进行“增加”，
               // 相当于将原始值添加到BIT中。
               // 如果是需要支持单点设值，则需要先计算差值再update。
               update(i, nums[i]);
           }
       }
   
       // 获取最低位的 1 (x & -x)
       private int lowbit(int x) {
           return x & (-x);
       }
   
       /**
        * 更新数组中某个位置的值 (增加)
        * 将 nums[index] 增加 val
        * @param index 要更新的数组索引 (0-indexed)
        * @param val 增加的值
        */
       public void update(int index, int val) {
           // 将 0-indexed 转换为 1-indexed
           index++;
           while (index <= N) {
               bit[index] += val;
               index += lowbit(index); // 跳到下一个父节点
           }
       }
   
       /**
        * 查询从索引 0 到 index (包含) 的前缀和
        * @param index 查询区间的结束索引 (0-indexed)
        * @return 前缀和
        */
       public int prefixSum(int index) {
           // 将 0-indexed 转换为 1-indexed
           index++;
           int sum = 0;
           while (index > 0) {
               sum += bit[index];
               index -= lowbit(index); // 跳到下一个需要累加的区间
           }
           return sum;
       }
   
       /**
        * 查询数组中 left 到 right 区间 (包含) 的和
        * @param left 查询区间的起始索引 (0-indexed)
        * @param right 查询区间的结束索引 (0-indexed)
        * @return 区间和
        */
       public int rangeSum(int left, int right) {
           if (left > right || left < 0 || right >= N) {
               throw new IllegalArgumentException("Invalid range.");
           }
           return prefixSum(right) - prefixSum(left - 1);
       }
   
       public static void main(String[] args) {
           int[] nums = {1, 2, 3, 4, 5, 6, 7, 8};
           System.out.println("Initial array (conceptually): " + Arrays.toString(nums));
           FenwickTree ft = new FenwickTree(nums);
   
           System.out.println("Prefix sum up to index 3 (0-indexed): " + ft.prefixSum(3)); // Expected: 1+2+3+4 = 10
           System.out.println("Prefix sum up to index 7 (0-indexed): " + ft.prefixSum(7)); // Expected: 1+2+3+4+5+6+7+8 = 36
   
           System.out.println("Range sum from index 0 to 7 (0-indexed): " + ft.rangeSum(0, 7)); // Expected: 36
           System.out.println("Range sum from index 1 to 4 (0-indexed): " + ft.rangeSum(1, 4)); // Expected: 2+3+4+5 = 14
   
           // 更新索引 2 的值 (从 3 增加 5，变为 8)
           ft.update(2, 5);
           System.out.println("\nUpdated index 2 by adding 5. (Conceptually array is [1, 2, 8, 4, 5, 6, 7, 8])");
           System.out.println("Prefix sum up to index 3 after update: " + ft.prefixSum(3)); // Expected: 1+2+8+4 = 15
           System.out.println("Range sum from index 1 to 4 after update: " + ft.rangeSum(1, 4)); // Expected: 2+8+4+5 = 19
   
           // 另一个测试用例
           int[] nums2 = {1, 0, 3, 0, 5};
           System.out.println("\nInitial array (conceptually): " + Arrays.toString(nums2));
           FenwickTree ft2 = new FenwickTree(nums2);
           System.out.println("Range sum from index 0 to 4: " + ft2.rangeSum(0, 4)); // Expected: 1+0+3+0+5 = 9
           ft2.update(1, 7); // 将索引 1 的值从 0 增加 7，变为 7
           System.out.println("Updated index 1 by adding 7. (Conceptually array is [1, 7, 3, 0, 5])");
           System.out.println("Range sum from index 0 to 4 after update: " + ft2.rangeSum(0, 4)); // Expected: 1+7+3+0+5 = 16
       }
   }
   ```
