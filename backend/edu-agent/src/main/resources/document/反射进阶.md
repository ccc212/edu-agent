## 37. 反射进阶 (Advanced Reflection)

### 37.1. 动态代理 (Dynamic Proxies)

- **知识点：** 动态代理的目的与应用场景（在运行时创建接口的实现类，用于日志、性能监控、事务管理等 AOP 场景）；`java.lang.reflect.Proxy` 类；`InvocationHandler` 接口。

1. **题目名称：** 实现一个简单的日志动态代理 **题目描述：**

   - 定义一个接口 `CalculatorService`，包含 `add(int a, int b)` 和 `subtract(int a, int b)` 方法。

   - 实现一个具体类 `CalculatorServiceImpl`。

   - 实现一个 

     ```
     LoggingInvocationHandler
     ```

     ，它实现 

     ```
     InvocationHandler
     ```

      接口。在 

     ```
     invoke
     ```

      方法中：

     - 打印方法调用的开始日志（方法名、参数）。
     - 调用实际对象的方法。
     - 打印方法调用的结束日志（方法名、返回值或异常）。

   - 在 `main` 方法中，使用 `Proxy.newProxyInstance()` 创建 `CalculatorService` 的动态代理实例，然后通过代理实例调用 `add` 和 `subtract` 方法，观察日志输出。 **参考代码结构：**

   **`CalculatorService.java`**

   ```java
   // CalculatorService.java
   public interface CalculatorService {
       int add(int a, int b);
       int subtract(int a, int b);
   }
   
   // CalculatorServiceImpl.java
   class CalculatorServiceImpl implements CalculatorService {
       @Override
       public int add(int a, int b) {
           return a + b;
       }
   
       @Override
       public int subtract(int a, int b) {
           return a - b;
       }
   }
   
   // LoggingInvocationHandler.java
   import java.lang.reflect.InvocationHandler;
   import java.lang.reflect.Method;
   import java.util.Arrays;
   
   class LoggingInvocationHandler implements InvocationHandler {
       private final Object target; // 实际被代理的对象
   
       public LoggingInvocationHandler(Object target) {
           this.target = target;
       }
   
       @Override
       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
           System.out.println("--- Before method call ---");
           System.out.println("Method: " + method.getName());
           System.out.println("Args: " + Arrays.toString(args));
   
           Object result;
           try {
               result = method.invoke(target, args); // 调用实际对象的方法
               System.out.println("--- After method call (success) ---");
               System.out.println("Result: " + result);
               return result;
           } catch (Throwable e) {
               System.err.println("--- After method call (exception) ---");
               System.err.println("Exception: " + e.getCause().getMessage()); // 获取实际异常
               throw e.getCause(); // 重新抛出实际异常
           }
       }
   }
   
   // Main.java
   import java.lang.reflect.Proxy;
   
   public class DynamicProxyDemo {
       public static void main(String[] args) {
           // 1. 创建实际对象
           CalculatorService calculator = new CalculatorServiceImpl();
   
           // 2. 创建 InvocationHandler 实例
           InvocationHandler handler = new LoggingInvocationHandler(calculator);
   
           // 3. 创建代理实例
           CalculatorService proxyCalculator = (CalculatorService) Proxy.newProxyInstance(
               calculator.getClass().getClassLoader(), // 类加载器
               new Class[]{CalculatorService.class},    // 代理要实现的接口
               handler                                  // InvocationHandler
           );
   
           // 4. 通过代理调用方法
           System.out.println("\nCalling add method via proxy:");
           int sum = proxyCalculator.add(10, 5);
           System.out.println("Sum from proxy: " + sum);
   
           System.out.println("\nCalling subtract method via proxy:");
           int diff = proxyCalculator.subtract(20, 7);
           System.out.println("Difference from proxy: " + diff);
   
           System.out.println("\nCalling add method that might cause an error (e.g. if target was null):");
           // 模拟一个代理抛出异常的场景（例如如果实际方法抛出异常）
           // 如果 CalculatorServiceImpl.add 方法会抛出异常，这里也会被 LoggingInvocationHandler 捕获并重新抛出
           // int errorResult = proxyCalculator.add(Integer.MAX_VALUE, 1); // 溢出
           // System.out.println("Error result: " + errorResult);
       }
   }
   ```