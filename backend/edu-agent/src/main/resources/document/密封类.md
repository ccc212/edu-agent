## 30. 密封类 (Sealed Classes) (Java 17+)

### 30.1. 密封类的定义与使用 (Sealed Class Definition & Usage)

- **知识点：** `sealed` 关键字的引入与目的（显式声明一个类或接口可以被哪些类或接口继承/实现，限制继承层级）；`permits` 关键字；`non-sealed` 关键字；与模式匹配结合使用。
- **注意：** 密封类是 Java 17 及更高版本中的特性。

1. **题目名称：** 实现一个密封图形家族 **题目描述：**

   - 定义一个密封接口 `Shape`，它只允许 `Circle` 和 `Rectangle` 实现它。
   - `Circle` 和 `Rectangle` 分别实现 `Shape` 接口，并包含计算面积的方法。`Circle` 应该有一个 `radius` 属性，`Rectangle` 应该有 `width` 和 `height` 属性。
   - 确保 `Circle` 类是 `final` 的，`Rectangle` 类是 `non-sealed` 的，允许 `Rectangle` 被进一步继承（例如 `Square`）。
   - 在 `main` 方法中，创建 `Circle` 和 `Rectangle` 实例，调用其面积计算方法，并验证 `Shape` 接口的密封性（例如尝试创建不允许的实现类并观察编译错误）。 **参考代码结构：**

   **`Shape.java`**

   ```java
   // Shape.java
   // 密封接口，只允许 Circle 和 Rectangle 实现
   public sealed interface Shape permits Circle, Rectangle {
       double area();
   }
   
   // Circle.java (final 类，不能被继承)
   final class Circle implements Shape {
       private final double radius;
   
       public Circle(double radius) {
           this.radius = radius;
       }
   
       @Override
       public double area() {
           return Math.PI * radius * radius;
       }
   
       @Override
       public String toString() {
           return "Circle[radius=" + radius + "]";
       }
   }
   
   // Rectangle.java (non-sealed 类，可以被进一步继承)
   non-sealed class Rectangle implements Shape {
       private final double width;
       private final double height;
   
       public Rectangle(double width, double height) {
           this.width = width;
           this.height = height;
       }
   
       @Override
       public double area() {
           return width * height;
       }
   
       public double getWidth() { return width; }
       public double getHeight() { return height; }
   
       @Override
       public String toString() {
           return "Rectangle[width=" + width + ", height=" + height + "]";
       }
   }
   
   // Square.java (继承自 Rectangle，因为 Rectangle 是 non-sealed)
   final class Square extends Rectangle { // Square 也可以是 sealed 或 non-sealed
       public Square(double side) {
           super(side, side);
       }
   
       @Override
       public String toString() {
           return "Square[side=" + getWidth() + "]";
       }
   }
   
   // Main.java
   public class SealedClassDemo {
       public static void main(String[] args) {
           Shape circle = new Circle(5.0);
           Shape rectangle = new Rectangle(4.0, 6.0);
           Shape square = new Square(7.0); // 合法的继承
   
           System.out.println(circle + ", Area: " + circle.area());
           System.out.println(rectangle + ", Area: " + rectangle.area());
           System.out.println(square + ", Area: " + square.area());
   
           // 尝试定义一个非法的实现类 (编译时会报错)
           /*
           class Triangle implements Shape { // 编译错误: class Triangle is not allowed to implement sealed interface Shape
               @Override
               public double area() { return 0; }
           }
           */
   
           // 结合模式匹配 (如果你的Java版本支持 switch 表达式的模式匹配，Java 21+)
           // processShapeWithPatternMatching(circle);
           // processShapeWithPatternMatching(rectangle);
           // processShapeWithPatternMatching(square);
       }
   
       // Java 21+ 的 switch 表达式模式匹配示例 (如果需要，可以作为额外题目)
       /*
       public static void processShapeWithPatternMatching(Shape shape) {
           String description = switch (shape) {
               case Circle c -> "This is a circle with area " + c.area();
               case Rectangle r -> "This is a rectangle with area " + r.area();
               // sealed 接口的好处是，编译器知道所有可能的子类，
               // 如果遗漏了某个，会提示 switch 表达式不完全
           };
           System.out.println(description);
       }
       */
   }
   ```
