## 44. 字符串算法 (String Algorithms)

### 44.1. 模式匹配 (Pattern Matching)

- **知识点：** 字符串的基本操作；朴素模式匹配 (Brute-Force)；KMP 算法 (Knuth-Morris-Pratt)。

1. **题目名称：** 朴素模式匹配 **题目描述：** 给定一个主字符串 `text` 和一个模式字符串 `pattern`，在 `text` 中查找 `pattern` 第一次出现的位置。如果未找到，返回 -1。

   - 实现一个静态方法 `bruteForceSearch(String text, String pattern)`。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   text = "ABABDABACDABABCABAB", pattern = "ABABCABAB"
   ```

   **输出示例：**

   ```
   Pattern found at index: 10
   ```

   **知识点描述：**

   - **工作原理：** 朴素模式匹配算法是暴力匹配，将模式串的每一个字符与主串的对应字符进行比较，如果匹配失败，则主串的指针后移一位，模式串的指针回到起始位置，继续比较。
   - **时间复杂度：** 最坏情况 O(M⋅N) (M 是模式串长度，N 是主串长度)。
   - **空间复杂度：** O(1)。
   - **适用场景：** 模式串和主串长度都较小，或对性能要求不高。

   **参考代码结构：**

   ```java
   public class BruteForceStringSearch {
   
       public static int bruteForceSearch(String text, String pattern) {
           int n = text.length();
           int m = pattern.length();
   
           if (m == 0) return 0; // 空模式串在任何位置都算匹配
           if (n == 0 || m > n) return -1; // 主串为空或模式串比主串长
   
           for (int i = 0; i <= n - m; i++) { // 遍历主串的每个可能的起始位置
               int j;
               for (j = 0; j < m; j++) { // 比较模式串的每个字符
                   if (text.charAt(i + j) != pattern.charAt(j)) {
                       break; // 字符不匹配，跳出内层循环
                   }
               }
               if (j == m) {
                   return i; // 整个模式串都匹配成功
               }
           }
           return -1; // 未找到匹配
       }
   
       public static void main(String[] args) {
           String text1 = "ABABDABACDABABCABAB";
           String pattern1 = "ABABCABAB";
           System.out.println("Text: \"" + text1 + "\", Pattern: \"" + pattern1 + "\"");
           int index1 = bruteForceSearch(text1, pattern1);
           System.out.println("Pattern found at index: " + index1); // Expected: 10
   
           String text2 = "AAAAABAAAB";
           String pattern2 = "AAAB";
           System.out.println("\nText: \"" + text2 + "\", Pattern: \"" + pattern2 + "\"");
           int index2 = bruteForceSearch(text2, pattern2);
           System.out.println("Pattern found at index: " + index2); // Expected: 6
   
           String text3 = "HelloWorld";
           String pattern3 = "World";
           System.out.println("\nText: \"" + text3 + "\", Pattern: \"" + pattern3 + "\"");
           int index3 = bruteForceSearch(text3, pattern3);
           System.out.println("Pattern found at index: " + index3); // Expected: 5
   
           String text4 = "Test";
           String pattern4 = "No";
           System.out.println("\nText: \"" + text4 + "\", Pattern: \"" + pattern4 + "\"");
           int index4 = bruteForceSearch(text4, pattern4);
           System.out.println("Pattern found at index: " + index4); // Expected: -1
       }
   }
   ```

2. **题目名称：** KMP 模式匹配算法 **题目描述：** 实现 KMP (Knuth-Morris-Pratt) 字符串模式匹配算法。KMP 算法通过预处理模式串，生成一个“部分匹配表”（LPS 数组），从而在匹配失败时避免不必要的回溯，提高效率。

   - 实现一个静态方法 `kmpSearch(String text, String pattern)`，返回 `pattern` 在 `text` 中第一次出现的位置。如果未找到，返回 -1。
   - 你需要先实现一个 `computeLPSArray(String pattern)` 方法来构建 LPS (Longest Proper Prefix which is also Suffix) 数组。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   text = "ABABDABACDABABCABAB", pattern = "ABABCABAB"
   ```

   **输出示例：**

   ```
   Pattern found at index (KMP): 10
   ```

   **知识点描述：**

   - **LPS 数组：** `lps[i]` 存储模式串 `pattern[0...i]` 最长的**真前缀**，它同时也是 `pattern[0...i]` 的**后缀**的长度。这个数组指导 KMP 在不匹配时模式串应该“跳过”多少位。
   - **工作原理：** KMP 算法利用已匹配的前缀信息，在遇到不匹配时，不是简单地将模式串向右移动一位，而是根据 LPS 数组的指示，移动到可以继续匹配的位置。
   - **时间复杂度：** O(N+M) (预处理 LPS 数组 O(M)，匹配 O(N))。
   - **空间复杂度：** O(M) (LPS 数组)。
   - **适用场景：** 大规模文本中查找模式，对性能要求高。

   **参考代码结构：**

   ```java
   import java.util.Arrays;
   
   public class KMPStringSearch {
   
       /**
        * 计算模式串的 LPS (Longest Proper Prefix which is also Suffix) 数组。
        * lps[i] 存储 pattern[0...i] 最长的真前缀，它同时也是 pattern[0...i] 的后缀的长度。
        *
        * @param pattern 模式字符串
        * @return LPS 数组
        */
       public static int[] computeLPSArray(String pattern) {
           int m = pattern.length();
           int[] lps = new int[m];
           int length = 0; // 最长真前缀后缀的长度
           int i = 1; // 当前正在处理的模式串索引
   
           lps[0] = 0; // lps[0] 总是 0
   
           while (i < m) {
               if (pattern.charAt(i) == pattern.charAt(length)) {
                   length++;
                   lps[i] = length;
                   i++;
               } else { // (pattern.charAt(i) != pattern.charAt(length))
                   if (length != 0) {
                       length = lps[length - 1]; // 回溯到上一个较短的公共前缀后缀
                   } else { // length == 0
                       lps[i] = 0;
                       i++;
                   }
               }
           }
           return lps;
       }
   
       /**
        * 使用 KMP 算法在文本中查找模式串第一次出现的位置。
        *
        * @param text    主字符串
        * @param pattern 模式字符串
        * @return 模式串在主串中的起始索引，如果未找到则返回 -1
        */
       public static int kmpSearch(String text, String pattern) {
           int n = text.length();
           int m = pattern.length();
   
           if (m == 0) return 0;
           if (n == 0 || m > n) return -1;
   
           int[] lps = computeLPSArray(pattern);
           // System.out.println("LPS Array for \"" + pattern + "\": " + Arrays.toString(lps));
   
           int i = 0; // text 的指针
           int j = 0; // pattern 的指针
   
           while (i < n) {
               if (pattern.charAt(j) == text.charAt(i)) {
                   i++;
                   j++;
               }
   
               if (j == m) { // 模式串完全匹配
                   return i - j; // 返回匹配的起始索引
               } else if (i < n && pattern.charAt(j) != text.charAt(i)) {
                   // 字符不匹配
                   if (j != 0) {
                       j = lps[j - 1]; // 根据 LPS 数组跳过已匹配部分
                   } else {
                       i++; // pattern 的第一个字符都不匹配，主串指针后移
                   }
               }
           }
           return -1; // 未找到匹配
       }
   
       public static void main(String[] args) {
           String text1 = "ABABDABACDABABCABAB";
           String pattern1 = "ABABCABAB";
           System.out.println("Text: \"" + text1 + "\", Pattern: \"" + pattern1 + "\"");
           int index1 = kmpSearch(text1, pattern1);
           System.out.println("Pattern found at index (KMP): " + index1); // Expected: 10
   
           String text2 = "AAAAABAAAB";
           String pattern2 = "AAAB";
           System.out.println("\nText: \"" + text2 + "\", Pattern: \"" + pattern2 + "\"");
           int index2 = kmpSearch(text2, pattern2);
           System.out.println("Pattern found at index (KMP): " + index2); // Expected: 6
   
           String text3 = "ABCDEFG";
           String pattern3 = "EFG";
           System.out.println("\nText: \"" + text3 + "\", Pattern: \"" + pattern3 + "\"");
           int index3 = kmpSearch(text3, pattern3);
           System.out.println("Pattern found at index (KMP): " + index3); // Expected: 4
   
           String text4 = "Test";
           String pattern4 = "No";
           System.out.println("\nText: \"" + text4 + "\", Pattern: \"" + pattern4 + "\"");
           int index4 = kmpSearch(text4, pattern4);
           System.out.println("Pattern found at index (KMP): " + index4); // Expected: -1
   
           String text5 = "AAAAA";
           String pattern5 = "AAA";
           System.out.println("\nText: \"" + text5 + "\", Pattern: \"" + pattern5 + "\"");
           int index5 = kmpSearch(text5, pattern5);
           System.out.println("Pattern found at index (KMP): " + index5); // Expected: 0
       }
   }
   ```

### 44.2. 最长回文子串 (Longest Palindromic Substring)

- **知识点：** 回文串定义；中心扩展法 (Expand Around Center)；动态规划。

1. **题目名称：** 查找最长回文子串 **题目描述：** 给定一个字符串 `s`，找到 `s` 中最长的回文子串。

   - 实现一个静态方法 `longestPalindrome(String s)`。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   s = "babad"
   ```

   **输出示例：** (可以返回 "bab" 或 "aba"，任选一个即可)

   ```
   Longest palindromic substring: bab
   ```

   **知识点描述：**

   - **中心扩展法：** 回文串要么是奇数长度（中心一个字符），要么是偶数长度（中心两个字符）。从每个可能的中心向两边扩展，直到不是回文串为止。

   - 动态规划：

     ```
     dp[i][j]
     ```

      表示子串 

     ```
     s[i...j]
     ```

      是否是回文串。

     - `dp[i][j] = (s.charAt(i) == s.charAt(j)) && dp[i+1][j-1]`。
     - 基础情况：单个字符是回文，两个相同字符也是回文。

   - **时间复杂度：** O(N2) (中心扩展法和动态规划)。

   - **空间复杂度：** O(1) (中心扩展法) 或 O(N2) (动态规划)。

   - **适用场景：** 需要找出字符串中的回文结构。

   **参考代码结构：**

   ```java
   public class LongestPalindromicSubstring {
   
       // 方法一：中心扩展法
       public static String longestPalindrome(String s) {
           if (s == null || s.length() == 0) {
               return "";
           }
   
           int start = 0; // 最长回文子串的起始索引
           int end = 0;   // 最长回文子串的结束索引
   
           for (int i = 0; i < s.length(); i++) {
               // 以 i 为中心，处理奇数长度回文串 (如 "aba")
               int len1 = expandAroundCenter(s, i, i);
               // 以 i 和 i+1 为中心，处理偶数长度回文串 (如 "abba")
               int len2 = expandAroundCenter(s, i, i + 1);
   
               int len = Math.max(len1, len2);
               if (len > (end - start + 1)) {
                   // 更新最长回文子串的起始和结束索引
                   start = i - (len - 1) / 2;
                   end = i + len / 2;
               }
           }
           return s.substring(start, end + 1);
       }
   
       private static int expandAroundCenter(String s, int left, int right) {
           while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
               left--;
               right++;
           }
           return right - left - 1; // 返回回文串的长度
       }
   
       // 方法二：动态规划 (可选，如果题目要求实现)
       public static String longestPalindromeDP(String s) {
           if (s == null || s.length() == 0) {
               return "";
           }
   
           int n = s.length();
           boolean[][] dp = new boolean[n][n]; // dp[i][j] 表示 s[i...j] 是否为回文串
           String ans = "";
   
           // 填充 dp 表
           // l 表示子串的长度
           for (int l = 0; l < n; l++) {
               for (int i = 0; i < n - l; i++) {
                   int j = i + l; // j 是子串的结束索引
   
                   if (l == 0) { // 单个字符是回文
                       dp[i][j] = true;
                   } else if (l == 1) { // 两个字符的情况
                       dp[i][j] = (s.charAt(i) == s.charAt(j));
                   } else { // 长度大于2的情况
                       dp[i][j] = (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]);
                   }
   
                   // 如果 dp[i][j] 是回文，且比当前找到的最长回文串长
                   if (dp[i][j] && l + 1 > ans.length()) {
                       ans = s.substring(i, j + 1);
                   }
               }
           }
           return ans;
       }
   
   
       public static void main(String[] args) {
           String s1 = "babad";
           System.out.println("String: \"" + s1 + "\", Longest Palindromic Substring: " + longestPalindrome(s1)); // Expected: bab or aba
   
           String s2 = "cbbd";
           System.out.println("String: \"" + s2 + "\", Longest Palindromic Substring: " + longestPalindrome(s2)); // Expected: bb
   
           String s3 = "a";
           System.out.println("String: \"" + s3 + "\", Longest Palindromic Substring: " + longestPalindrome(s3)); // Expected: a
   
           String s4 = "ac";
           System.out.println("String: \"" + s4 + "\", Longest Palindromic Substring: " + longestPalindrome(s4)); // Expected: a or c
   
           System.out.println("\n--- Using DP method ---");
           System.out.println("String: \"" + s1 + "\", Longest Palindromic Substring (DP): " + longestPalindromeDP(s1));
           System.out.println("String: \"" + s2 + "\", Longest Palindromic Substring (DP): " + longestPalindromeDP(s2));
       }
   }
   ```
