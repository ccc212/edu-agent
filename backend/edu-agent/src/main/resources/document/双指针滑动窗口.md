## 53. 双指针 / 滑动窗口 (Two Pointers / Sliding Window)

### 53.1. 双指针 (Two Pointers)

- **知识点：** 快慢指针、对撞指针、左右指针、相同方向指针。

1. **题目名称：** 有序数组的平方 **题目描述：** 给你一个按非递减顺序排序的整数数组 `nums`，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。

   - 实现一个静态方法 `sortedSquares(int[] nums)`。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   nums = {-4, -1, 0, 3, 10}
   ```

   **输出示例：**

   ```
   Original array: [-4, -1, 0, 3, 10]
   Sorted squares: [0, 1, 9, 16, 100]
   ```

   **知识点描述：**

   - **核心思想：** 虽然直接平方再排序可行（O(NlogN)），但由于原数组是有序的，其平方后最大值可能在两端（负数绝对值最大或正数最大）。可以使用双指针法，从数组两端向中间遍历，将平方后的较大值依次放入新数组的末尾。
   - **指针设置：** `left` 指针指向数组开头，`right` 指针指向数组结尾，`k` 指针指向结果数组的结尾。
   - **操作：** 比较 `nums[left] * nums[left]` 和 `nums[right] * nums[right]`，将较大者放入 `result[k]`，然后移动对应的指针（`left++` 或 `right--`），同时 `k--`。
   - **时间复杂度：** O(N)。
   - **空间复杂度：** O(N) (用于存储结果数组)。

   **参考代码结构：**

   ```java
   import java.util.Arrays;
   
   public class SortedSquares {
   
       public static int[] sortedSquares(int[] nums) {
           int n = nums.length;
           int[] result = new int[n];
           int left = 0;
           int right = n - 1;
           int k = n - 1; // 结果数组的填充指针，从后往前填充
   
           while (left <= right) {
               int squareLeft = nums[left] * nums[left];
               int squareRight = nums[right] * nums[right];
   
               if (squareLeft > squareRight) {
                   result[k] = squareLeft;
                   left++;
               } else {
                   result[k] = squareRight;
                   right--;
               }
               k--;
           }
           return result;
       }
   
       public static void main(String[] args) {
           int[] nums1 = {-4, -1, 0, 3, 10};
           System.out.println("Original array: " + Arrays.toString(nums1));
           System.out.println("Sorted squares: " + Arrays.toString(sortedSquares(nums1))); // Expected: [0, 1, 9, 16, 100]
   
           int[] nums2 = {-7, -3, 2, 3, 11};
           System.out.println("\nOriginal array: " + Arrays.toString(nums2));
           System.out.println("Sorted squares: " + Arrays.toString(sortedSquares(nums2))); // Expected: [4, 9, 9, 49, 121]
   
           int[] nums3 = {-1, 0, 1};
           System.out.println("\nOriginal array: " + Arrays.toString(nums3));
           System.out.println("Sorted squares: " + Arrays.toString(sortedSquares(nums3))); // Expected: [0, 1, 1]
   
           int[] nums4 = {0};
           System.out.println("\nOriginal array: " + Arrays.toString(nums4));
           System.out.println("Sorted squares: " + Arrays.toString(sortedSquares(nums4))); // Expected: [0]
       }
   }
   ```

### 53.2. 滑动窗口 (Sliding Window)

- **知识点：** 窗口的扩张与收缩；维护窗口内的状态。

1. **题目名称：** 长度最小的子数组 **题目描述：** 给定一个含有 `n` 个正整数的数组 `nums` 和一个正整数 `target`。找出该数组中满足其和 ≥target 的长度最小的连续子数组。如果不存在符合条件的子数组，返回 0。

   - 实现一个静态方法 `minSubArrayLen(int target, int[] nums)`。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   target = 7, nums = {2, 3, 1, 2, 4, 3}
   ```

   **输出示例：**

   ```
   Array: [2, 3, 1, 2, 4, 3], Target: 7
   Minimum length of subarray: 2 (Subarray is [4, 3])
   ```

   **知识点描述：**

   - **核心思想：** 使用两个指针 `left` 和 `right` 定义一个“窗口”。`right` 指针向右移动以扩张窗口，直到窗口内的和达到或超过 `target`。一旦满足条件，`left` 指针向右移动以收缩窗口，同时更新最小长度，直到窗口内的和不再满足条件。

   - **变量维护：** 维护一个 `currentSum` 记录当前窗口内的和，以及 `minLength` 记录满足条件的最小长度。

   - 操作：

     1. `right` 扩张：`currentSum += nums[right]`。

     2. 当 

        ```
        currentSum >= target
        ```

         时：

        - 更新 `minLength = min(minLength, right - left + 1)`。
        - `left` 收缩：`currentSum -= nums[left]`, `left++`。

     3. 重复直到 `right` 遍历完数组。

   - **时间复杂度：** O(N) (每个元素最多被 `left` 和 `right` 指针访问两次)。

   - **空间复杂度：** O(1)。

   **参考代码结构：**

   ```java
   import java.util.Arrays;
   
   public class MinimumSubarrayLength {
   
       public static int minSubArrayLen(int target, int[] nums) {
           if (nums == null || nums.length == 0) {
               return 0;
           }
   
           int n = nums.length;
           int minLength = Integer.MAX_VALUE;
           int left = 0;
           int currentSum = 0;
   
           System.out.println("Array: " + Arrays.toString(nums) + ", Target: " + target);
   
           for (int right = 0; right < n; right++) {
               currentSum += nums[right];
   
               // 当当前窗口的和 >= target 时，尝试收缩窗口
               while (currentSum >= target) {
                   minLength = Math.min(minLength, right - left + 1); // 更新最小长度
                   currentSum -= nums[left]; // 移除左边元素
                   left++; // 左指针右移
               }
           }
   
           // 如果 minLength 仍然是初始值，表示没有找到符合条件的子数组
           return (minLength == Integer.MAX_VALUE) ? 0 : minLength;
       }
   
       public static void main(String[] args) {
           int[] nums1 = {2, 3, 1, 2, 4, 3};
           int target1 = 7;
           System.out.println("Minimum length of subarray: " + minSubArrayLen(target1, nums1)); // Expected: 2 (Subarray is [4, 3])
   
           int[] nums2 = {1, 4, 4};
           int target2 = 4;
           System.out.println("\nMinimum length of subarray: " + minSubArrayLen(target2, nums2)); // Expected: 1 (Subarray is [4])
   
           int[] nums3 = {1, 1, 1, 1, 1, 1, 1, 1};
           int target3 = 11;
           System.out.println("\nMinimum length of subarray: " + minSubArrayLen(target3, nums3)); // Expected: 0
   
           int[] nums4 = {1, 2, 3, 4, 5};
           int target4 = 15;
           System.out.println("\nMinimum length of subarray: " + minSubArrayLen(target4, nums4)); // Expected: 5
       }
   }
   ```
