## 9. 多线程 (Multithreading)

### 9.1. 线程的创建与启动 (Thread Creation & Start)

- **知识点：** 进程与线程的概念；实现多线程的两种方式（继承 `Thread` 类，实现 `Runnable` 接口）；线程的生命周期；`start()` 方法与 `run()` 方法的区别。

1. **题目名称：** 简单的计数线程 (继承 Thread) **题目描述：**

   - 创建一个类 `MyCounterThread` 继承自 `Thread`。
   - 在 `run()` 方法中，打印从 1 到 5 的数字，并在每次打印之间暂停 100 毫秒。
   - 在 `main` 方法中，创建 `MyCounterThread` 的两个实例，并分别启动它们，观察输出。 **参考代码结构：**

   Java

   ```
   // MyCounterThread.java
   class MyCounterThread extends Thread {
       @Override
       public void run() {
           // 在这里编写你的代码
       }
   }
   
   // Main.java
   public class ThreadExtensionDemo {
       public static void main(String[] args) {
           // 在这里创建并启动线程
       }
   }
   ```

2. **题目名称：** 并发问候 (实现 Runnable) **题目描述：**

   - 创建一个类 `GreeterRunnable` 实现 `Runnable` 接口。
   - 构造方法接收一个 `name` 字符串。
   - 在 `run()` 方法中，打印 "Hello from [name]!" 5 次，并在每次打印之间暂停 50 毫秒。
   - 在 `main` 方法中，创建两个 `GreeterRunnable` 实例（例如 "Alice" 和 "Bob"），并将它们分别包装在 `Thread` 对象中启动。 **参考代码结构：**

   Java

   ```
   // GreeterRunnable.java
   class GreeterRunnable implements Runnable {
       private String name;
   
       public GreeterRunnable(String name) {
           this.name = name;
       }
   
       @Override
       public void run() {
           // 在这里编写你的代码
       }
   }
   
   // Main.java
   public class RunnableImplementationDemo {
       public static void main(String[] args) {
           // 在这里创建并启动线程
       }
   }
   ```

### 9.2. 线程同步与通信 (Thread Synchronization & Communication)

- **知识点：** 线程安全问题；同步块 (`synchronized` 关键字，`this` 对象锁，类锁)；同步方法；死锁；`wait()`, `notify()`, `notifyAll()` 方法；`volatile` 关键字；`Lock` 接口（`ReentrantLock`）；`Condition` 接口；原子操作类（`AtomicInteger` 等）。

1. **题目名称：** 银行账户存取款 (synchronized 方法) **题目描述：**

   - 定义一个 `BankAccount` 类，包含一个 `balance` (double) 属性。
   - 提供 `deposit(double amount)` 和 `withdraw(double amount)` 方法。
   - 使用 `synchronized` 关键字修饰这两个方法，确保对 `balance` 的操作是线程安全的。
   - 在 `main` 方法中，创建 `BankAccount` 实例。创建多个线程，一部分线程执行存款操作，另一部分执行取款操作，观察最终余额是否正确。 **参考代码结构：**

   Java

   ```
   // BankAccount.java
   class BankAccount {
       private double balance = 0;
   
       public synchronized void deposit(double amount) {
           // 在这里编写你的代码
       }
   
       public synchronized void withdraw(double amount) {
           // 在这里编写你的代码
       }
   
       public double getBalance() {
           return balance;
       }
   }
   
   // Main.java
   public class BankAccountSyncDemo {
       public static void main(String[] args) {
           BankAccount account = new BankAccount();
           // 创建存款线程
           Thread depositThread = new Thread(() -> {
               for (int i = 0; i < 1000; i++) {
                   account.deposit(1);
               }
           });
           // 创建取款线程
           Thread withdrawThread = new Thread(() -> {
               for (int i = 0; i < 1000; i++) {
                   account.withdraw(1);
               }
           });
   
           depositThread.start();
           withdrawThread.start();
   
           try {
               depositThread.join();
               withdrawThread.join();
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
   
           System.out.println("Final Balance: " + account.getBalance());
       }
   }
   ```

2. **题目名称：** 生产者-消费者问题 (wait/notifyAll) **题目描述：**

   - 模拟一个简单的生产者-消费者问题。
   - 定义一个共享的 `Buffer` 类，用于存储数据，容量有限。
   - `Buffer` 包含 `put(int data)` 和 `get()` 方法，这两个方法需要考虑缓冲区满和空的情况，并使用 `wait()`, `notifyAll()` 进行线程间通信。
   - 创建 `Producer` 线程，向 `Buffer` 中放入数据。
   - 创建 `Consumer` 线程，从 `Buffer` 中取出数据。
   - 在 `main` 方法中，启动生产者和消费者线程，观察它们的协同工作。 **参考代码结构：**

   Java

   ```
   import java.util.LinkedList;
   import java.util.Queue;
   
   // Buffer.java
   class Buffer {
       private Queue<Integer> queue = new LinkedList<>();
       private int capacity;
   
       public Buffer(int capacity) {
           this.capacity = capacity;
       }
   
       public void put(int data) throws InterruptedException {
           // 在这里编写你的代码
       }
   
       public int get() throws InterruptedException {
           // 在这里编写你的代码
           return -1;
       }
   }
   
   // Producer.java
   class Producer implements Runnable {
       private Buffer buffer;
       public Producer(Buffer buffer) { this.buffer = buffer; }
       @Override
       public void run() {
           try {
               for (int i = 0; i < 10; i++) {
                   System.out.println("Producing: " + i);
                   buffer.put(i);
                   Thread.sleep(50);
               }
           } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
       }
   }
   
   // Consumer.java
   class Consumer implements Runnable {
       private Buffer buffer;
       public Consumer(Buffer buffer) { this.buffer = buffer; }
       @Override
       public void run() {
           try {
               for (int i = 0; i < 10; i++) {
                   int data = buffer.get();
                   System.out.println("Consuming: " + data);
                   Thread.sleep(100);
               }
           } catch (InterruptedException e) { Thread.currentThread().interrupt(); }
       }
   }
   
   // Main.java
   public class ProducerConsumerDemo {
       public static void main(String[] args) {
           Buffer buffer = new Buffer(5);
           Thread producerThread = new Thread(new Producer(buffer));
           Thread consumerThread = new Thread(new Consumer(buffer));
   
           producerThread.start();
           consumerThread.start();
       }
   }
   ```

### 9.3. 线程池与并发工具 (Thread Pools & Concurrency Utilities)

- **知识点：** 线程池的概念与优势；`ExecutorService` 接口；`Executors` 工厂类（`newFixedThreadPool`, `newCachedThreadPool`, `newSingleThreadExecutor`）；`Future` 接口；`Callable` 接口；`CountDownLatch`；`CyclicBarrier`；`Semaphore`。

1. **题目名称：** 使用线程池执行任务 **题目描述：**

   - 创建一个固定大小为 3 的线程池。
   - 定义一个 `Runnable` 任务，在 `run()` 方法中打印当前线程的名称和任务编号，并随机暂停一段时间。
   - 提交 10 个这样的任务到线程池中执行。
   - 最后关闭线程池。 **参考代码结构：**

   Java

   ```
   import java.util.concurrent.ExecutorService;
   import java.util.concurrent.Executors;
   import java.util.concurrent.TimeUnit;
   import java.util.Random;
   
   public class ThreadPoolDemo {
       public static void main(String[] args) {
           // 创建线程池
           ExecutorService executor = Executors.newFixedThreadPool(3);
   
           // 提交任务
           for (int i = 0; i < 10; i++) {
               final int taskId = i;
               executor.submit(() -> {
                   // 在这里编写你的任务逻辑
               });
           }
   
           // 关闭线程池
           executor.shutdown();
           try {
               executor.awaitTermination(1, TimeUnit.MINUTES);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
           System.out.println("All tasks submitted and processed.");
       }
   }
   ```

2. **题目名称：** 计算异步任务结果 (Callable & Future) **题目描述：**

   - 定义一个 `Callable` 任务，它接收两个整数，计算它们的和，并返回结果。
   - 在 `main` 方法中，使用 `ExecutorService` 提交 3 个这样的 `Callable` 任务，并使用 `Future` 对象获取每个任务的计算结果，然后打印。 **参考代码结构：**

   Java

   ```
   import java.util.concurrent.Callable;
   import java.util.concurrent.ExecutionException;
   import java.util.concurrent.ExecutorService;
   import java.util.concurrent.Executors;
   import java.util.concurrent.Future;
   import java.util.concurrent.TimeUnit;
   
   public class CallableFutureDemo {
       // 定义一个实现Callable接口的类
       static class SumCalculator implements Callable<Integer> {
           private int a;
           private int b;
   
           public SumCalculator(int a, int b) {
               this.a = a;
               this.b = b;
           }
   
           @Override
           public Integer call() throws Exception {
               // 在这里编写你的计算逻辑
               return a + b;
           }
       }
   
       public static void main(String[] args) {
           ExecutorService executor = Executors.newFixedThreadPool(2);
           Future<Integer> future1 = executor.submit(new SumCalculator(5, 10));
           Future<Integer> future2 = executor.submit(new SumCalculator(20, 30));
           Future<Integer> future3 = executor.submit(new SumCalculator(7, 8));
   
           try {
               // 获取结果
               System.out.println("Result 1: " + future1.get());
               System.out.println("Result 2: " + future2.get());
               System.out.println("Result 3: " + future3.get());
           } catch (InterruptedException | ExecutionException e) {
               e.printStackTrace();
           } finally {
               executor.shutdown();
           }
       }
   }
   ```
