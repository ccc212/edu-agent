## 38. 排序算法 (Sorting Algorithms)

### 38.1. 比较排序 (Comparison Sorts)

- **知识点：** 排序算法的基本概念；稳定性；时间复杂度（最好、平均、最坏）；空间复杂度。

1. **题目名称：** 实现冒泡排序 (Bubble Sort) **题目描述：** 冒泡排序是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。

   - 实现一个静态方法 `bubbleSort(int[] arr)`，对传入的整数数组进行升序排序。
   - 在 `main` 方法中，用一个示例数组测试你的实现，并打印排序前后的数组。 **输入示例：** `int[] arr = {64, 34, 25, 12, 22, 11, 90};` **输出示例：**

   ```
   Original array: [64, 34, 25, 12, 22, 11, 90]
   Sorted array (Bubble Sort): [11, 12, 22, 25, 34, 64, 90]
   ```

   **知识点描述：**

   - **工作原理：** 比较相邻元素并交换，使较大/较小的元素“冒泡”到正确的位置。
   - **时间复杂度：** O(N2) (平均、最坏、最好)。
   - **空间复杂度：** O(1) (原地排序)。
   - **稳定性：** 稳定。
   - **适用场景：** 数据量非常小，或教学演示。

   **参考代码结构：**

   ```java
   import java.util.Arrays;
   
   public class BubbleSort {
       public static void bubbleSort(int[] arr) {
           int n = arr.length;
           boolean swapped;
           for (int i = 0; i < n - 1; i++) {
               swapped = false;
               for (int j = 0; j < n - 1 - i; j++) {
                   if (arr[j] > arr[j + 1]) {
                       // 交换 arr[j] 和 arr[j+1]
                       int temp = arr[j];
                       arr[j] = arr[j + 1];
                       arr[j + 1] = temp;
                       swapped = true;
                   }
               }
               // 如果一趟下来没有发生交换，说明数组已经有序
               if (!swapped) {
                   break;
               }
           }
       }
   
       public static void main(String[] args) {
           int[] arr = {64, 34, 25, 12, 22, 11, 90};
           System.out.println("Original array: " + Arrays.toString(arr));
           bubbleSort(arr);
           System.out.println("Sorted array (Bubble Sort): " + Arrays.toString(arr));
       }
   }
   ```

2. **题目名称：** 实现选择排序 (Selection Sort) **题目描述：** 选择排序是一种简单直观的排序算法。它首先在未排序序列中找到最小（或最大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（或最大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

   - 实现一个静态方法 `selectionSort(int[] arr)`，对传入的整数数组进行升序排序。
   - 在 `main` 方法中，用一个示例数组测试你的实现，并打印排序前后的数组。 **输入示例：** `int[] arr = {64, 34, 25, 12, 22, 11, 90};` **输出示例：**

   ```
   Original array: [64, 34, 25, 12, 22, 11, 90]
   Sorted array (Selection Sort): [11, 12, 22, 25, 34, 64, 90]
   ```

   **知识点描述：**

   - **工作原理：** 每轮从未排序部分找到最小元素，并将其放到已排序部分的末尾。
   - **时间复杂度：** O(N2) (平均、最坏、最好)。
   - **空间复杂度：** O(1) (原地排序)。
   - **稳定性：** 不稳定 (例如 5, 8, 5, 2 排序后第一个 5 可能与第二个 5 交换顺序)。
   - **适用场景：** 数据量小，对稳定性无要求。

   **参考代码结构：**

   ```java
   import java.util.Arrays;
   
   public class SelectionSort {
       public static void selectionSort(int[] arr) {
           int n = arr.length;
           for (int i = 0; i < n - 1; i++) {
               int minIdx = i;
               for (int j = i + 1; j < n; j++) {
                   if (arr[j] < arr[minIdx]) {
                       minIdx = j;
                   }
               }
               // 将找到的最小元素与当前位置交换
               int temp = arr[minIdx];
               arr[minIdx] = arr[i];
               arr[i] = temp;
           }
       }
   
       public static void main(String[] args) {
           int[] arr = {64, 34, 25, 12, 22, 11, 90};
           System.out.println("Original array: " + Arrays.toString(arr));
           selectionSort(arr);
           System.out.println("Sorted array (Selection Sort): " + Arrays.toString(arr));
       }
   }
   ```

3. **题目名称：** 实现插入排序 (Insertion Sort) **题目描述：** 插入排序的原理是，通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。算法在数组很小或者基本有序时表现良好。

   - 实现一个静态方法 `insertionSort(int[] arr)`，对传入的整数数组进行升序排序。
   - 在 `main` 方法中，用一个示例数组测试你的实现，并打印排序前后的数组。 **输入示例：** `int[] arr = {12, 11, 13, 5, 6};` **输出示例：**

   ```
   Original array: [12, 11, 13, 5, 6]
   Sorted array (Insertion Sort): [5, 6, 11, 12, 13]
   ```

   **知识点描述：**

   - **工作原理：** 将每个元素插入到已排序部分的正确位置。
   - **时间复杂度：** O(N2) (平均、最坏)，O(N) (最好，当数组已几乎有序时)。
   - **空间复杂度：** O(1) (原地排序)。
   - **稳定性：** 稳定。
   - **适用场景：** 数据量小；数据几乎有序。

   **参考代码结构：**

   ```java
   import java.util.Arrays;
   
   public class InsertionSort {
       public static void insertionSort(int[] arr) {
           int n = arr.length;
           for (int i = 1; i < n; i++) {
               int key = arr[i]; // 当前要插入的元素
               int j = i - 1;
   
               // 将已排序部分中比 key 大的元素向右移动
               while (j >= 0 && arr[j] > key) {
                   arr[j + 1] = arr[j];
                   j = j - 1;
               }
               arr[j + 1] = key; // 插入 key
           }
       }
   
       public static void main(String[] args) {
           int[] arr = {12, 11, 13, 5, 6};
           System.out.println("Original array: " + Arrays.toString(arr));
           insertionSort(arr);
           System.out.println("Sorted array (Insertion Sort): " + Arrays.toString(arr));
       }
   }
   ```

4. **题目名称：** 实现归并排序 (Merge Sort) **题目描述：** 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。它将一个数组分成两半，分别对两半进行排序，然后将两个已排序的子数组合并成一个。

   - 实现一个静态方法 `mergeSort(int[] arr)`，对传入的整数数组进行升序排序。
   - 你需要实现一个递归的 `mergeSort` 方法和一个 `merge` 方法。
   - 在 `main` 方法中，用一个示例数组测试你的实现，并打印排序前后的数组。 **输入示例：** `int[] arr = {38, 27, 43, 3, 9, 82, 10};` **输出示例：**

   ```
   Original array: [38, 27, 43, 3, 9, 82, 10]
   Sorted array (Merge Sort): [3, 9, 10, 27, 38, 43, 82]
   ```

   **知识点描述：**

   - **工作原理：** 分治法。递归地将数组分成两半，直到子数组只剩一个元素（有序），然后合并（merge）已排序的子数组。
   - **时间复杂度：** O(NlogN) (平均、最坏、最好)。
   - **空间复杂度：** O(N) (需要额外空间进行合并)。
   - **稳定性：** 稳定。
   - **适用场景：** 对稳定性有要求，数据量大，链表排序。

   **参考代码结构：**

   ```java
   import java.util.Arrays;
   
   public class MergeSort {
   
       public static void mergeSort(int[] arr) {
           if (arr == null || arr.length <= 1) {
               return;
           }
           sort(arr, new int[arr.length], 0, arr.length - 1);
       }
   
       private static void sort(int[] arr, int[] temp, int left, int right) {
           if (left < right) {
               int mid = (left + right) / 2;
               sort(arr, temp, left, mid);      // 排序左半部分
               sort(arr, temp, mid + 1, right); // 排序右半部分
               merge(arr, temp, left, mid, right); // 合并两部分
           }
       }
   
       private static void merge(int[] arr, int[] temp, int left, int mid, int right) {
           // 将 arr[left...right] 复制到 temp[left...right]
           for (int i = left; i <= right; i++) {
               temp[i] = arr[i];
           }
   
           int i = left;      // 左半部分的起始索引
           int j = mid + 1;   // 右半部分的起始索引
           int k = left;      // 合并后数组的起始索引
   
           // 比较两部分元素，依次放入 arr
           while (i <= mid && j <= right) {
               if (temp[i] <= temp[j]) {
                   arr[k] = temp[i];
                   i++;
               } else {
                   arr[k] = temp[j];
                   j++;
               }
               k++;
           }
   
           // 将左半部分剩余元素放入 arr
           while (i <= mid) {
               arr[k] = temp[i];
               k++;
               i++;
           }
   
           // 将右半部分剩余元素放入 arr (如果需要)
           while (j <= right) {
               arr[k] = temp[j];
               k++;
               j++;
           }
       }
   
       public static void main(String[] args) {
           int[] arr = {38, 27, 43, 3, 9, 82, 10};
           System.out.println("Original array: " + Arrays.toString(arr));
           mergeSort(arr);
           System.out.println("Sorted array (Merge Sort): " + Arrays.toString(arr));
       }
   }
   ```

5. **题目名称：** 实现快速排序 (Quick Sort) **题目描述：** 快速排序是一种非常高效的排序算法，它采用分治法。通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

   - 实现一个静态方法 `quickSort(int[] arr)`，对传入的整数数组进行升序排序。
   - 你需要实现一个递归的 `quickSort` 方法和一个 `partition` 方法。
   - 在 `main` 方法中，用一个示例数组测试你的实现，并打印排序前后的数组。 **输入示例：** `int[] arr = {10, 80, 30, 90, 40, 50, 70};` **输出示例：**

   ```
   Original array: [10, 80, 30, 90, 40, 50, 70]
   Sorted array (Quick Sort): [10, 30, 40, 50, 70, 80, 90]
   ```

   **知识点描述：**

   - **工作原理：** 分治法。选择一个基准元素（pivot），将数组分为两部分：小于基准的、大于基准的。然后递归地对这两部分进行排序。
   - **时间复杂度：** O(NlogN) (平均)，O(N2) (最坏，当选择的基准不佳时)。
   - **空间复杂度：** O(logN) (平均，递归栈空间)，O(N) (最坏)。
   - **稳定性：** 不稳定。
   - **适用场景：** 大部分情况下的首选排序算法，性能优秀。

   **参考代码结构：**

   ```java
   import java.util.Arrays;
   
   public class QuickSort {
   
       public static void quickSort(int[] arr) {
           if (arr == null || arr.length <= 1) {
               return;
           }
           sort(arr, 0, arr.length - 1);
       }
   
       private static void sort(int[] arr, int low, int high) {
           if (low < high) {
               // pi 是分区索引，arr[pi] 现在在正确的位置
               int pi = partition(arr, low, high);
   
               // 递归地对左右两部分进行排序
               sort(arr, low, pi - 1);
               sort(arr, pi + 1, high);
           }
       }
   
       private static int partition(int[] arr, int low, int high) {
           int pivot = arr[high]; // 选择最后一个元素作为基准
           int i = (low - 1); // 小于基准的元素的索引
   
           for (int j = low; j < high; j++) {
               // 如果当前元素小于或等于基准
               if (arr[j] <= pivot) {
                   i++;
   
                   // 交换 arr[i] 和 arr[j]
                   int temp = arr[i];
                   arr[i] = arr[j];
                   arr[j] = temp;
               }
           }
   
           // 将基准元素放到正确的位置
           int temp = arr[i + 1];
           arr[i + 1] = arr[high];
           arr[high] = temp;
   
           return i + 1; // 返回基准元素的最终位置
       }
   
       public static void main(String[] args) {
           int[] arr = {10, 80, 30, 90, 40, 50, 70};
           System.out.println("Original array: " + Arrays.toString(arr));
           quickSort(arr);
           System.out.println("Sorted array (Quick Sort): " + Arrays.toString(arr));
       }
   }
   ```

6. **题目名称：** 实现堆排序 (Heap Sort) **题目描述：** 堆排序是一种树形选择排序，是对直接选择排序的有效改进。堆是一种特殊的完全二叉树，它满足堆的性质：父节点的值总是大于或等于（或小于或等于）其子节点的值。堆排序利用堆这种数据结构所设计的一种排序算法。

   - 实现一个静态方法 `heapSort(int[] arr)`，对传入的整数数组进行升序排序。
   - 你需要实现 `heapify`（堆化）方法来维护堆的性质。
   - 在 `main` 方法中，用一个示例数组测试你的实现，并打印排序前后的数组。 **输入示例：** `int[] arr = {12, 11, 13, 5, 6, 7};` **输出示例：**

   ```
   Original array: [12, 11, 13, 5, 6, 7]
   Sorted array (Heap Sort): [5, 6, 7, 11, 12, 13]
   ```

   **知识点描述：**

   - **工作原理：** 将数组视为一个完全二叉树，构建大顶堆（或小顶堆），然后将堆顶元素（最大或最小）与数组末尾元素交换，再对剩余元素进行堆化。
   - **时间复杂度：** O(NlogN) (平均、最坏、最好)。
   - **空间复杂度：** O(1) (原地排序)。
   - **稳定性：** 不稳定。
   - **适用场景：** 效率高，不占用额外空间，但不如快速排序在实际场景中常用。

   **参考代码结构：**

   ```java
   import java.util.Arrays;
   
   public class HeapSort {
   
       public static void heapSort(int[] arr) {
           int n = arr.length;
   
           // 1. 构建大顶堆 (从最后一个非叶子节点开始，向上堆化)
           // 最后一个非叶子节点索引为 n/2 - 1
           for (int i = n / 2 - 1; i >= 0; i--) {
               heapify(arr, n, i);
           }
   
           // 2. 一个个从堆顶取出元素
           for (int i = n - 1; i > 0; i--) {
               // 将当前堆顶（最大元素）与数组末尾元素交换
               int temp = arr[0];
               arr[0] = arr[i];
               arr[i] = temp;
   
               // 对剩余的堆进行堆化 (减少堆的大小)
               heapify(arr, i, 0);
           }
       }
   
       // 堆化方法，维护以 rootIdx 为根的子树为大顶堆
       private static void heapify(int[] arr, int n, int rootIdx) {
           int largest = rootIdx;       // 初始化最大元素为根
           int left = 2 * rootIdx + 1;  // 左子节点
           int right = 2 * rootIdx + 2; // 右子节点
   
           // 如果左子节点比根大
           if (left < n && arr[left] > arr[largest]) {
               largest = left;
           }
   
           // 如果右子节点比目前最大值大
           if (right < n && arr[right] > arr[largest]) {
               largest = right;
           }
   
           // 如果最大值不是根节点
           if (largest != rootIdx) {
               int swap = arr[rootIdx];
               arr[rootIdx] = arr[largest];
               arr[largest] = swap;
   
               // 递归地堆化受影响的子树
               heapify(arr, n, largest);
           }
       }
   
       public static void main(String[] args) {
           int[] arr = {12, 11, 13, 5, 6, 7};
           System.out.println("Original array: " + Arrays.toString(arr));
           heapSort(arr);
           System.out.println("Sorted array (Heap Sort): " + Arrays.toString(arr));
       }
   }
   ```

### 38.2. 非比较排序 (Non-Comparison Sorts)

- **知识点：** 非比较排序的原理（不通过元素间的比较来排序）；通常依赖于待排序元素的特定性质（如范围、位数）。

1. **题目名称：** 实现计数排序 (Counting Sort) **题目描述：** 计数排序不是基于比较的排序算法，其核心思想是将输入数据的值转化为键存储在额外开辟的数组空间中。适用于整数范围不大的情况。

   - 实现一个静态方法 `countingSort(int[] arr)`，对传入的整数数组进行升序排序。
   - 假定所有输入数字都是非负整数，且在一个可接受的较小范围内（例如 0 到 100）。
   - 在 `main` 方法中，用一个示例数组测试你的实现，并打印排序前后的数组。 **输入示例：** `int[] arr = {4, 2, 2, 8, 3, 3, 1};` **输出示例：**

   ```
   Original array: [4, 2, 2, 8, 3, 3, 1]
   Sorted array (Counting Sort): [1, 2, 2, 3, 3, 4, 8]
   ```

   **知识点描述：**

   - **工作原理：** 统计每个元素出现的次数，然后根据统计结果将元素放入输出数组。
   - **时间复杂度：** O(N+K) (其中 K 是数据范围)。
   - **空间复杂度：** O(K)。
   - **稳定性：** 稳定。
   - **适用场景：** 当输入元素是整数，且范围（K）相对较小或与数据量（N）相当时，非常高效。

   **参考代码结构：**

   ```java
   import java.util.Arrays;
   
   public class CountingSort {
   
       public static void countingSort(int[] arr) {
           if (arr == null || arr.length <= 1) {
               return;
           }
   
           // 1. 找到数组中的最大值 (确定计数数组的大小)
           int max = arr[0];
           for (int i = 1; i < arr.length; i++) {
               if (arr[i] > max) {
                   max = arr[i];
               }
           }
   
           // 2. 创建计数数组，并初始化为0
           int[] count = new int[max + 1];
   
           // 3. 填充计数数组 (统计每个元素的出现次数)
           for (int num : arr) {
               count[num]++;
           }
   
           // 4. 修改计数数组，使其每个元素存储其在输出数组中的最终位置
           for (int i = 1; i <= max; i++) {
               count[i] += count[i - 1];
           }
   
           // 5. 创建输出数组
           int[] output = new int[arr.length];
   
           // 6. 从原数组的末尾开始遍历，将元素放入输出数组的正确位置
           // 这样做可以保证稳定性
           for (int i = arr.length - 1; i >= 0; i--) {
               output[count[arr[i]] - 1] = arr[i]; // count[arr[i]] - 1 是当前元素在输出数组中的索引
               count[arr[i]]--; // 更新计数，防止重复元素覆盖
           }
   
           // 7. 将排序好的结果复制回原数组
           for (int i = 0; i < arr.length; i++) {
               arr[i] = output[i];
           }
       }
   
       public static void main(String[] args) {
           int[] arr = {4, 2, 2, 8, 3, 3, 1};
           System.out.println("Original array: " + Arrays.toString(arr));
           countingSort(arr);
           System.out.println("Sorted array (Counting Sort): " + Arrays.toString(arr));
   
           int[] arr2 = {9, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9};
           System.out.println("\nOriginal array 2: " + Arrays.toString(arr2));
           countingSort(arr2);
           System.out.println("Sorted array 2 (Counting Sort): " + Arrays.toString(arr2));
       }
   }
   ```
