## 60. 优先队列的应用 (Applications of Priority Queue)

### 60.1. 合并 K 个排序链表 (Merge K Sorted Lists)

- **知识点：** 优先队列 (PriorityQueue / 小顶堆)；链表操作；多路归并。

1. **题目名称：** 合并 K 个排序链表 **题目描述：** 给你一个链表数组，每个链表都已经按升序排列。请将所有链表合并到一个升序的链表中，并返回合并后的链表。

   - 实现一个静态方法 `mergeKLists(ListNode[] lists)`。
   - 需要提供 `ListNode` 类定义。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   lists = {
       1->4->5,
       1->3->4,
       2->6
   }
   ```

   **输出示例：**

   ```
   Input lists:
   1->4->5
   1->3->4
   2->6
   Merged list: 1->1->2->3->4->4->5->6
   ```

   **知识点描述：**

   - **核心思想：** 这是一种经典的多路归并问题。最直接的方法是两两合并（时间复杂度较高），或者将所有元素取出来排序再构建链表（空间复杂度较高）。最优解是使用**优先队列（小顶堆）**。
   - 优先队列的应用：
     1. 将所有链表的第一个节点（头节点）加入优先队列。优先队列会根据节点的值进行排序，最小的节点总是位于队头。
     2. 每次从优先队列中取出最小的节点（队头元素）。
     3. 将取出的节点添加到合并后的链表。
     4. 如果该节点有下一个节点，则将其下一个节点加入优先队列。
     5. 重复步骤 2-4，直到优先队列为空。
   - **`ListNode` 比较：** `ListNode` 类需要实现 `Comparable` 接口，或者在创建 `PriorityQueue` 时提供一个 `Comparator`，以便优先队列能正确比较节点的值。
   - **时间复杂度：** O(NlogK)，其中 N 是所有链表中的总节点数，K 是链表的数量。每个节点被添加到优先队列一次，弹出一次，每次操作的复杂度是 O(logK)。
   - **空间复杂度：** O(K) (优先队列中最多存储 K 个节点，即每个链表的一个当前节点)。

   **参考代码结构：**

   ```java
   import java.util.PriorityQueue;
   
   // 链表节点定义
   class ListNode {
       int val;
       ListNode next;
   
       ListNode() {}
       ListNode(int val) { this.val = val; }
       ListNode(int val, ListNode next) { this.val = val; this.next = next; }
   
       @Override
       public String toString() {
           StringBuilder sb = new StringBuilder();
           ListNode current = this;
           while (current != null) {
               sb.append(current.val);
               if (current.next != null) {
                   sb.append("->");
               }
               current = current.next;
           }
           return sb.toString();
       }
   }
   
   public class MergeKSortedLists {
   
       public static ListNode mergeKLists(ListNode[] lists) {
           if (lists == null || lists.length == 0) {
               return null;
           }
   
           // 创建一个最小堆 (优先队列)，用于存储链表节点
           // 默认情况下，PriorityQueue 是小顶堆
           // 这里需要自定义比较器，因为 ListNode 不是基本类型
           PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);
   
           // 将所有链表的头节点加入优先队列
           for (ListNode list : lists) {
               if (list != null) {
                   minHeap.offer(list);
               }
           }
   
           // 虚拟头节点，便于构建新链表
           ListNode dummyHead = new ListNode(0);
           ListNode current = dummyHead;
   
           // 当优先队列不为空时，不断取出最小节点
           while (!minHeap.isEmpty()) {
               ListNode smallest = minHeap.poll(); // 取出当前最小的节点
               current.next = smallest;             // 将其添加到新链表
               current = current.next;              // 移动新链表的指针
   
               // 如果取出的节点有下一个节点，将其下一个节点加入优先队列
               if (smallest.next != null) {
                   minHeap.offer(smallest.next);
               }
           }
   
           return dummyHead.next; // 返回合并后的链表的头节点
       }
   
       // 辅助方法：创建链表
       private static ListNode createList(int... vals) {
           if (vals.length == 0) return null;
           ListNode dummy = new ListNode(0);
           ListNode current = dummy;
           for (int val : vals) {
               current.next = new ListNode(val);
               current = current.next;
           }
           return dummy.next;
       }
   
       public static void main(String[] args) {
           ListNode l1 = createList(1, 4, 5);
           ListNode l2 = createList(1, 3, 4);
           ListNode l3 = createList(2, 6);
   
           ListNode[] lists1 = {l1, l2, l3};
           System.out.println("Input lists:");
           for (ListNode node : lists1) {
               System.out.println(node);
           }
           ListNode mergedList1 = mergeKLists(lists1);
           System.out.println("Merged list: " + mergedList1); // Expected: 1->1->2->3->4->4->5->6
   
           System.out.println("\n--- Another Test Case ---");
           ListNode l4 = createList(); // 空链表
           ListNode l5 = createList(1, 2, 3);
           ListNode l6 = createList(4, 5);
           ListNode[] lists2 = {l4, l5, l6};
           System.out.println("Input lists:");
           for (ListNode node : lists2) {
               if (node == null) System.out.println("null");
               else System.out.println(node);
           }
           ListNode mergedList2 = mergeKLists(lists2);
           System.out.println("Merged list: " + mergedList2); // Expected: 1->2->3->4->5
   
           System.out.println("\n--- Empty Input Test Case ---");
           ListNode[] lists3 = {};
           System.out.println("Input lists: {}");
           ListNode mergedList3 = mergeKLists(lists3);
           System.out.println("Merged list: " + mergedList3); // Expected: null
       }
   }
   ```