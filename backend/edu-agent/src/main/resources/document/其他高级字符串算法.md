## 57. 其他高级字符串算法 (Other Advanced String Algorithms)

### 57.1. Rabin-Karp 算法 (Rolling Hash)

- **知识点：** 字符串哈希；滚动哈希 (Rolling Hash)；哈希碰撞处理。

1. **题目名称：** Rabin-Karp 字符串匹配 **题目描述：** 实现 Rabin-Karp 算法，在一个文本字符串 `text` 中查找模式字符串 `pattern` 的所有出现位置。Rabin-Karp 算法利用哈希值来快速排除不匹配的子串，从而提高匹配效率。你需要选择一个合适的素数作为模数 `q` 和一个基数 `d` (通常是字符集大小)。当哈希值匹配时，需要进行逐字符比较以处理哈希碰撞。

   - 实现一个静态方法 `RabinKarpSearch(String text, String pattern)`。
   - 返回所有匹配起始索引的列表。如果 `pattern` 不在 `text` 中出现，返回空列表。
   - 在 `main` 方法中，用多个示例测试你的实现。 **输入示例：**

   ```
   text = "GEEKS FOR GEEKS", pattern = "GEEK"
   ```

   **输出示例：**

   ```
   Pattern "GEEK" found at index: [0, 10]
   ```

   **知识点描述：**

   - **核心思想：** 通过计算模式串和文本串中等长子串的哈希值进行比较。如果哈希值不相等，则子串肯定不匹配；如果哈希值相等，则可能匹配（需要进一步验证），也可能发生哈希碰撞。
   - **滚动哈希：** KMP 算法的优化在于避免不必要的回溯，而 Rabin-Karp 的优化在于快速跳过不匹配的子串。滚动哈希允许你在 O(1) 时间内计算下一个子串的哈希值，而不是每次都从头计算。
   - **哈希函数：** 通常采用多项式哈希函数：H=(c0⋅dk−1+c1⋅dk−2+⋯+ck−1⋅d0)(modq)，其中 `d` 是基数（例如 256 表示 ASCII 字符），`q` 是一个大素数。
   - **滚动哈希的计算：** 假设当前子串 Si=T[i…i+M−1] 的哈希值为 Hi。下一个子串 Si+1=T[i+1…i+M] 的哈希值可以通过 Hi 快速计算： Hi+1=(d⋅(Hi−T[i]⋅dM−1)+T[i+M])(modq)。 需要注意的是，减法可能产生负数，所以要加上 `q` 再取模： Hi+1=(d⋅(Hi−T[i]⋅powD)+T[i+M])(modq)，其中 powD=dM−1(modq)。
   - **哈希碰撞处理：** 当模式串哈希值与文本子串哈希值相等时，必须进行逐字符比较来确认是否真的匹配。这是因为不同的字符串可能有相同的哈希值。
   - 时间复杂度：
     - 平均情况：O(N+M)。
     - 最坏情况：O(N⋅M) (如果哈希函数选择不当或存在大量哈希碰撞)。
   - **空间复杂度：** O(1) (不计输入输出)。
   - **适用场景：** 字符串匹配，尤其适用于多模式串匹配 (将所有模式串的哈希值存储起来)。

   **参考代码结构：**

   ```java
   import java.util.ArrayList;
   import java.util.List;
   
   public class RabinKarp {
   
       // 定义基数 (通常是字符集大小，例如 256 代表扩展 ASCII)
       private static final int D = 256;
       // 定义一个大素数作为模数，用于避免溢出和减少哈希碰撞
       private static final int Q = 101; // 一个小素数用于示例，实际应用中会更大
   
       /**
        * 使用 Rabin-Karp 算法在文本中查找模式串的所有出现位置。
        *
        * @param text 文本字符串
        * @param pattern 模式字符串
        * @return 所有匹配起始索引的列表
        */
       public static List<Integer> RabinKarpSearch(String text, String pattern) {
           List<Integer> result = new ArrayList<>();
           int N = text.length();
           int M = pattern.length();
   
           if (M == 0) return new ArrayList<>(); // 空模式串总是匹配
           if (N == 0 || N < M) return new ArrayList<>(); // 空文本或文本短于模式串
   
           int patternHash = 0; // 模式串的哈希值
           int textWindowHash = 0; // 当前文本窗口的哈希值
           int h = 1; // 用于计算 D^(M-1) % Q
   
           // 预先计算 D^(M-1) % Q，用于移除最左边字符时的计算
           for (int i = 0; i < M - 1; i++) {
               h = (h * D) % Q;
           }
   
           // 计算模式串和文本第一个窗口的哈希值
           for (int i = 0; i < M; i++) {
               patternHash = (D * patternHash + pattern.charAt(i)) % Q;
               textWindowHash = (D * textWindowHash + text.charAt(i)) % Q;
           }
   
           // 滑动窗口并比较哈希值
           for (int i = 0; i <= N - M; i++) {
               // 如果哈希值匹配，则进行逐字符验证，以处理哈希碰撞
               if (patternHash == textWindowHash) {
                   boolean match = true;
                   for (int j = 0; j < M; j++) {
                       if (text.charAt(i + j) != pattern.charAt(j)) {
                           match = false;
                           break;
                       }
                   }
                   if (match) {
                       result.add(i); // 找到匹配
                   }
               }
   
               // 计算下一个文本窗口的哈希值（如果不是最后一个窗口）
               if (i < N - M) {
                   // 移除最左边的字符并加上最右边的新字符
                   textWindowHash = (D * (textWindowHash - text.charAt(i) * h) + text.charAt(i + M)) % Q;
   
                   // 处理 textWindowHash 可能为负数的情况
                   if (textWindowHash < 0) {
                       textWindowHash = (textWindowHash + Q);
                   }
               }
           }
           return result;
       }
   
       public static void main(String[] args) {
           String text1 = "GEEKS FOR GEEKS";
           String pattern1 = "GEEK";
           List<Integer> matches1 = RabinKarpSearch(text1, pattern1);
           System.out.println("Text: \"" + text1 + "\", Pattern: \"" + pattern1 + "\"");
           System.out.println("Pattern \"" + pattern1 + "\" found at index: " + matches1); // Expected: [0, 10]
   
           String text2 = "ABABABABAB";
           String pattern2 = "ABA";
           List<Integer> matches2 = RabinKarpSearch(text2, pattern2);
           System.out.println("\nText: \"" + text2 + "\", Pattern: \"" + pattern2 + "\"");
           System.out.println("Pattern \"" + pattern2 + "\" found at index: " + matches2); // Expected: [0, 2, 4, 6]
   
           String text3 = "abcdefg";
           String pattern3 = "xyz";
           List<Integer> matches3 = RabinKarpSearch(text3, pattern3);
           System.out.println("\nText: \"" + text3 + "\", Pattern: \"" + pattern3 + "\"");
           System.out.println("Pattern \"" + pattern3 + "\" found at index: " + matches3); // Expected: []
   
           String text4 = "AAAAA";
           String pattern4 = "AAA";
           List<Integer> matches4 = RabinKarpSearch(text4, pattern4);
           System.out.println("\nText: \"" + text4 + "\", Pattern: \"" + pattern4 + "\"");
           System.out.println("Pattern \"" + pattern4 + "\" found at index: " + matches4); // Expected: [0, 1, 2]
       }
   }
   ```
